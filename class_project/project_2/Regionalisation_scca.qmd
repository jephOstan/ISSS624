---
title: "Regionalisation with Spatially Constrained Cluster Analysis"
editor: visual
date: 5 Dec 2022
reference-location: margin
citation-location: margin
---

case study : ***Regionalisation by Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods.***

# 1. OVERVIEW

Regionalisation with Spatially Constrained clustering analysis requires similar observations to be grouped according to their statistical attributes and spatial location.

This study focuses on regionalising analysis based on Nigeria's water points attributes.

## 1.1 Objectives

Regionalise Nigeria by using the following measures :

-   Total number of water points by status, i.e. functional, non-functional, and unknown;

-   Percentage of water points by :

    -   status (functional, non-functional, and unknown);

    -   deployed water technology (hand pump, mechanical pump, stand tap, etc.) ;

    -   usage capacity (1000, 300, 250, 50);

    -   rural or urban.

## 1.2 Study Area

::: {.callout-caution collapse="true"}
[**water points in Federal Republic of Nigeria**]{style="color:#3b3128"}

Alpha-3 Code : **NGA**

Population : **225 million** (1st in Africa, 6th globally)

Local Government Areas (LGA) : 774

Water Point Observations : 95,008

Environmental Aspects :

**Geography** :

-   Southwest - "rugged" highland.

-   Southeast - hills and mountains, which form the Mambilla Plateau, the highest plateau in Nigeria.

**Hydrology** :

-   Two (2) main catchment areas - Chad Basin & Niger catchment area.

-   Surface area of lake Chad is shrinking recent decades due to irrigation activities.[^1]

-   Untreated wastes dump in places resulted in waterways and groundwater pollution.[^2]

**Vegetation Coverage** :

-   Lost nearly 80% of primary forest by 2012.[^3]

-   States with dense forests concentrated : Bayelsa, Cross River, Edo, Ekiti, Ondo, Osun, Rivers, and Taraba.
:::

[^1]: Wikipedia. *Nigeria.* https://en.wikipedia.org/wiki/Nigeria

[^2]: Ogbonna, D.N., Ekweozor, I.K.E., Igwe, F.U. (2002). "Waste Management: A Tool for Environmental Protection in Nigeria". *Ambio: A Journal of the Human Environment*. **31** (1): 55--57. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1639/0044-7447(2002)031\[0055:wmatfe\]2.0.co;2](https://doi.org/10.1639%2F0044-7447%282002%29031%5B0055%3Awmatfe%5D2.0.co%3B2).

[^3]: https://rainforests.mongabay.com/20nigeria.htm

## 1.3 Scope of Works

Some of the specific tasks for this study are :

-   import the shapefile into R with the appropriate *sf* method, and save it in a simple feature data frame format;

::: callout-note
**note**

Three (3) Projected Coordinate Systems of Nigeria, EPSG : [26391](https://epsg.io/26391), 26392, and 26303.
:::

-   derive the proportion of functional and non-functional water points at LGA level (i.e. ADM2) by appropriate tidyr and dplyr methods;

-   combine geospatial and aspatial data frames into a simple feature data frame.

-   delineate water points measures functional regions by using :

    -   conventional hierarchical clustering.

    -   spatially constrained clustering algorithms.

-   plot two (2) main types of maps below :

    **Thematic Mapping**

    Show the derived water-point measures by appropriate statistical graphics and choropleth mapping technique.

    **Analytical Mapping**

    Plot delineated functional regions using non-spatially constrained and spatially constrained clustering algorithms.

<br>

# 2. R PACKAGE REQUIRED

The following are the packages required for this exercise :

::: {.callout-caution collapse="true"}
**Load one or more packages**

-   pacman package :

    -   [*p_load( )*](https://www.rdocumentation.org/packages/pacman/versions/0.5.1/topics/p_load) - [2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#load-r-packages-into-r-environment)
:::

::: {.callout-caution collapse="true"}
**Import and process Geospatial data**

-   sf package :

    -   [*st_as_sfc( )*](https://www.rdocumentation.org/packages/sf/versions/1.0-9/topics/st_as_sfc) - [3.2.5.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#derive-new-field-geometry)

    -   [*st_sf( )*](https://www.rdocumentation.org/packages/sf/versions/0.1-1/topics/ST_sf) - [3.2.5.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#convert-to-sf-data-frame)

    -   [*st_crs( )*](https://www.rdocumentation.org/packages/sf/versions/1.0-9/topics/st_crs)- [3.2.5.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#convert-to-sf-data-frame)

    -   [*st_geometry( )*](https://www.rdocumentation.org/packages/sf/versions/1.0-9/topics/st_geometry)- [3.2.5.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#retrieve-geometry-summary-wp_sf), [3.4.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#inspect-joined-file-wp_joined)

    -   [*st_read( )*](https://www.rdocumentation.org/packages/sf/versions/0.2-2/topics/st_read) - [3.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-boundary-data-of-nigeria-lga)

    -   [*st_join( )*](https://www.rdocumentation.org/packages/sf/versions/0.5-5/topics/st_join) - [3.4.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#join-objects-wp_sf-and-bdy_nga)

    -   *st_set_crs( )* - [3.4.5.20](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#transform-to-projected-coordinate-system)

    -   [*st_set_geometry( )*](https://r-spatial.github.io/sf/reference/st_geometry.html) *-* [4.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#create-data-table-for-correlation-matrix-analysis)

-   stars package :

    -   [*st_intersects( )*](https://www.rdocumentation.org/packages/stars/versions/0.5-0/topics/st_intersects.stars)- [3.4.5.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#add-attribute-to-new-data-table)
:::

::: {.callout-caution collapse="true"}
**Import and Process Aspatial data**

-   tidyverse :
    -   readr package :

        -   [*read_csv( )*](https://readr.tidyverse.org/reference/read_delim.html) - [3.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-coordinate-related-variable), [3.2.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-status-and-condition-related-variable), [3.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-lga-and-measure-related-variable), 3.2.2.1

        -   [*problems( )*](https://www.rdocumentation.org/packages/readr/versions/1.3.1/topics/problems) - [3.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-coordinate-related-variable), [3.2.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-status-and-condition-related-variable), [3.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-lga-and-measure-related-variable), [3.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-boundary-data-of-nigeria-lga)

        -   [*write_rds( )*](https://readr.tidyverse.org/reference/read_rds.html) *-* [3.2.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_coord), [3.2.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_cond), [3.2.3.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_adm), [3.4.2.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_joined), [3.4.5.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wpt_functional)

        -   [*read_rds( )*](https://readr.tidyverse.org/reference/read_rds.html)- [3.2.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_coord), [3.2.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_cond), [3.2.3.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_adm), [3.4.2.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_joined), [3.4.4.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#read-rds-file-wp_joined1), [3.4.5.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wpt_functional)

    -   dplyr :

        -   [*rename( )*](https://dplyr.tidyverse.org/reference/rename.html) - [3.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-coordinate-related-variable), [3.2.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-status-and-condition-related-variable), [3.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-lga-and-measure-related-variable)

        -   [*filter( )*](https://dplyr.tidyverse.org/reference/filter.html) - [3.3.1.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#list-the-duplicated-value-shapename), [3.4.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#validate-edited-value-shapename), [3.4.5.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#extract-functional-water-point)

        -   [*left_join( )*](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/join) - [3.2.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#create-master-file),

        -   [*select( )*](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/select) - [3.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-boundary-data-of-nigeria-lga), [3.3.1.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#list-the-duplicated-value-shapename), [3.4.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#validate-edited-value-shapename)

        -   [*add_count( )*](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/tally) - [3.3.1.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#list-the-duplicated-value-shapename), [3.4.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#validate-edited-value-shapename)

        -   [*mutate( )*](https://www.rdocumentation.org/packages/dplyr/versions/0.5.0/topics/mutate) - [3.4.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#replace-na-with-unknown), [3.4.4.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#combine-value-status_clean)

    -   tidyr :

        -   [*replace_na( )*](https://www.rdocumentation.org/packages/tidyr/versions/0.8.3/topics/replace_na) - [3.4.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#replace-na-with-unknown), [3.4.5.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#replace-nan-with-0)
:::

::: {.callout-caution collapse="true"}
**Plot map for visualisation**

-   tmap :

-   [*tmap_mode( )*](https://www.rdocumentation.org/packages/tmap/versions/3.3-3/topics/tmap_mode) - [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

-   [*tm_shape( )*](https://www.rdocumentation.org/packages/tmap/versions/3.3-3/topics/tm_shape) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

-   [*tm_polygons( )*](https://rdrr.io/cran/tmap/man/tm_polygons.html) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

-   [*tm_view( )*](https://rdrr.io/cran/tmap/man/tm_view.html) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

-   [*tm_fill( )*](https://search.r-project.org/CRAN/refmans/tmap/html/tm_polygons.html) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

-   [*tm_borders( )*](https://www.rdocumentation.org/packages/tmap/versions/0.7/topics/tm_borders) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

-   [*tmap_style( )*](https://rdrr.io/cran/tmap/man/tmap_style.html) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

-   [*tm_layout( )*](https://www.rdocumentation.org/packages/tmap/versions/3.3-3/topics/tm_layout) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

-   *qtm( )* - [3.4.5.12](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#visualise-distribution-status_clean)

-   *tmap_arrange( )* - [3.4.5.12](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#visualise-distribution-status_clean)
:::

::: {.callout-caution collapse="true"}
**Plot graph and chart**

-   ggplot2 package :

    -   [*ggplot( )*](https://www.rdocumentation.org/packages/ggplot2/versions/3.4.0/topics/ggplot) - [3.4.5.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#exploratory-data-analysis-eda-wpt_functional)

    -   [*geom_bar( )*](https://www.rdocumentation.org/packages/ggplot2/versions/1.0.1/topics/geom_bar) - [3.4.5.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#exploratory-data-analysis-eda-wpt_functional)

    -   [*geom_text( )*](https://www.rdocumentation.org/packages/ggplot2/versions/0.9.1/topics/geom_text) - [3.4.5.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#exploratory-data-analysis-eda-wpt_functional)

    -   [*scale_x\_discrete( )*](https://ggplot2.tidyverse.org/reference/scale_discrete.html) - [3.4.5.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#exploratory-data-analysis-eda-wpt_functional)

    -   [*geom_boxplot( )*](https://www.rdocumentation.org/packages/ggplot2/versions/1.0.1/topics/geom_boxplot)- [3.5.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#plot-boxplot-pct_functional)

    -   [*geom_histogram( )*](https://www.rdocumentation.org/packages/ggplot2/versions/0.9.1/topics/geom_histogram) - [3.5.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#plot-histogram-for-status_clean)

-   egg package :

    -   [*ggarrange( )*](https://www.rdocumentation.org/packages/egg/versions/0.4.5/topics/ggarrange) - [3.5.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#plot-histogram-for-status_clean)
:::

::: {.callout-caution collapse="true"}
**Visualise correlation matrix**

-   corrplot package :

    -   [*corrplot.mixed( )*](https://www.rdocumentation.org/packages/corrplot/versions/0.92/topics/corrplot.mixed) - [4.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#visualise-correlation-matrix-1)
:::

::: {.callout-caution collapse="true"}
**Get descriptive stats**

-   questionr :

    -   [*freq.na( )*](https://www.rdocumentation.org/packages/questionr/versions/0.7.7/topics/freq.na)- [3.3.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#check-for-missing-data)
    -   [*freq( )*](https://www.rdocumentation.org/packages/questionr/versions/0.7.7/topics/freq) *-* [3.3.1.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#check-for-duplication-shapename), [3.4.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#determine-reference-point-shapename-or-clean_adm2)

-   factoextra :

    -   [*fviz_nbclust( )*](https://www.rdocumentation.org/packages/factoextra/versions/1.0.7/topics/fviz_nbclust) -

-   stats :

    -   [*dist( )*](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/dist) - 5.1.2

    -   [*as.dist( )*](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/dist) -
:::

::: {.callout-caution collapse="true"}
**Miscellaneous Generic Functions**

-   janitor package :

    -   [*get_dupes( )*](https://www.rdocumentation.org/packages/janitor/versions/2.1.0/topics/get_dupes) *-* [3.4.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#assess-uniqueness-of-each-water-point)

-   [plyr package](https://www.rdocumentation.org/packages/plyr/versions/1.8.8) :

    -   *count( )* - [3.4.5.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#reveal-value-usage_capacity-by-status_clean)

-   [base package](https://www.rdocumentation.org/packages/base/versions/3.6.2) :

    -   [*summary( )*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/summary) - [3.2.1.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#review-data-frame-wp_coord), [3.2.2.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#review-data-frame-wp_cond), [3.2.3.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#review-data-frame-wp_adm), [3.4.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#reveal-value-crucialness_score), [3.4.5.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#reveal-value-crucialness_score-1)

    -   [*duplicated( )*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/duplicated) - [3.3.1.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#check-for-duplication-shapename)

    -   [*length( )*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/length)- [3.4.5.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#inspect-variable-and-value)

    -   [*sum( )*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/sum) *-* [3.4.5.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#determine-the-total-population-within-1-km-by-crucialness_score)
:::

## 2.1 Load R Packages into R Environment

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***p_load( )*** - pacman -]{style="color:#d46e15"} to load packages. This function will attempt to install the package from CRAN or pacman repository list if its found not installed.

```{r}
pacman::p_load(sf, tidyverse, questionr, janitor, psych, ggplot2, gcookbook, tmap, ggpubr, egg, corrplot, gtsummary, regclass, caret, heatmaply, ggdendro, cluster, factoextra, spdep, ClustGeo, GGally)
```

<br>

# 3. GEOSPATIAL DATA

## 3.1 Acquire Data Source

-   **Aspatial Data**

    1.  Download the Nigeria data set in shapefile format via [Access WPdx+ Global Data Repository](https://data.waterpointdata.org/dataset/Water-Point-Data-Exchange-Plus-WPDx-/eqje-vguj/data) from [WPdx Global Data Repositories](https://www.waterpointdata.org/access-data/).
    2.  Rename the title of the data set to "***geo_export***".

::: callout-note
The file size of the downloaded data is about 422 MB due to water points data from multiple countries.

To avoid any error of pushing files larger than 100 MB to Git cached in the Git Push function, filtered the water points for Nigeria and removed unnecessary variables. As a result, the file size is reduced to about 23 MB.
:::

-   **Geospatial Data**

    1.  Download the Nigeria geoBoundaries data set at ADM2 level from [geoBoundaries.org](https://www.geoboundaries.org/index.html#getdata) or the [Humanitarian Data Exchange portal](https://data.humdata.org/).
    2.  Rename the title of the data set to "***nga_admbnda_adm2_osgof_20190417***"

## 3.2 Import Aspatial Data

### 3.2.1 Import Coordinate-related Variable

::: {.callout-caution collapse="true"}
[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***read_csv( )*** - readr -]{style="color:#d46e15"} to import and save the comma separated value (CSV) file as a data frame, with title "*wp_coord*".

-   [**c*ol_select( )*** - readr -]{style="color:#d46e15"} to include only the selected variables into *wp_cood* data frame.

[***rename( )*** - dplyr -]{style="color:#d46e15"} to remove "\#" from the variables.

[***problems( )*** - readr -]{style="color:#d46e15"} to reveal any parsing errors when importing the CSV file.
:::

```{r}
wp_coord <- read_csv("/jephOstan/ISSS624/class_project/project_2/data/aspatial/WPdx_NGAv1.1.csv",
                       col_select = c(`row_id`,
                                      `#lat_deg`,
                                      `#lon_deg`,
                                      `New Georeferenced Column`,
                                      `lat_lon_deg`)) %>%
  rename(lat_deg = "#lat_deg", 
         lon_deg = "#lon_deg")

problems(wp_coord)

```

Remarks :

[Upload and create new data frames according to the context of the variables. Therewith, these data frames can be used as and when the requirements fit the context thereof.]{style="color:#d69c3c"}

#### 3.2.1.1 save and read RDS file :: *wp_coord*

::: {.callout-caution collapse="true"}
[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***write_rds( )*** - readr -]{style="color:#d46e15"} to save *wp_coord* data table into an RDS format.

-   note : compress the file with "xz".

[***read_rds( )*** - readr -]{style="color:#d46e15"} to read *wp_coord* RDS file into *wp_coord*.
:::

```{r}
write_rds(wp_coord,"/jephOstan/ISSS624/class_project/project_2/data/geodata/wp_coord.rds",compress = "xz")

wp_coord <- read_rds("/jephOstan/ISSS624/class_project/project_2/data/geodata/wp_coord.rds")
```

#### 3.2.1.2 review data frame :: *wp_coord*

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***summary( )*** - base -]{style="color:#d46e15"} to reveal any missing / "NA" observations.

```{r}
summary(wp_coord)
```

### 3.2.2 Import Status and Condition-related Variable

```{r}
wp_cond <- read_csv("/jephOstan/ISSS624/class_project/project_2/data/aspatial/WPdx_NGAv1.1.csv", 
                     col_select = c(`row_id`,
                                    `#water_source`,
                                    `#water_source_clean`,
                                    `#water_source_category`,
                                    `#water_tech_clean`,
                                    `#water_tech_category`,
                                    `#status_clean`,
                                    `#status`)) %>%
  rename(water_source = `#water_source`,
         water_source_clean = `#water_source_clean`, 
         water_source_category = `#water_source_category`, 
         water_tech_clean = `#water_tech_clean`, 
         water_tech_category = `#water_tech_category`,
         status_clean = `#status_clean`,
         status = `#status`)

problems(wp_cond)
```

#### 3.2.2.1 save and read RDS file :: *wp_cond*

```{r}
write_rds(wp_cond,"/jephOstan/ISSS624/class_project/project_2/data/geodata/wp_cond.rds",compress = "xz")

wp_cond <- read_rds("/jephOstan/ISSS624/class_project/project_2/data/geodata/wp_cond.rds")
```

#### 3.2.2.2 review data frame :: *wp_cond*

```{r}
summary(wp_cond)
```

### 3.2.3 Import LGA and Measure-related Variable

```{r}
wp_adm <- read_csv("/jephOstan/ISSS624/class_project/project_2/data/aspatial/WPdx_NGAv1.1.csv", 
                    col_select = c(`row_id`,
                                   `#clean_adm1`,
                                   `#clean_adm2`,
                                   `water_point_population`,
                                   `local_population_1km`,
                                   `crucialness_score`,
                                   `pressure_score`,
                                   `usage_capacity`,
                                   `staleness_score`,
                                   `rehab_priority`,
                                   `is_urban`)) %>%
  rename(clean_adm1 = `#clean_adm1`,
         clean_adm2 = `#clean_adm2`)

problems(wp_adm)
```

#### 3.2.3.1 save and read RDS file :: *wp_adm*

```{r}
write_rds(wp_adm,"/jephOstan/ISSS624/class_project/project_2/data/geodata/wp_adm.rds",compress = "xz")

wp_adm <- read_rds("/jephOstan/ISSS624/class_project/project_2/data/geodata/wp_adm.rds")
```

#### 3.2.3.2 review data frame :: *wp_adm*

```{r}
summary(wp_adm)
```

Remarks :

-   "staleness_score" indicates the depreciation of the data's relevance.

-   The observation updated within 1 year has a "staleness_score" of approximately \~ 89.13 or higher.

-   Water points data collection is usually done [quarterly or annually](https://www.ircwash.org/blog/giving-data-soul-case-study-use-water-point-data-uganda#:~:text=Water%20point%20data%20is%20largely,and%20water%20point%20asset%20mapping.).

    -   [Based on the code chunk below, only 11 out of 95008 water points are updated within 1 year (between June 2021 to Aug 2022), meaning the rest, which is almost entire observations (the latest updated date was in Apr 2020), are outdated.]{style="color:#d69c3c"}

    -   [These outdated observations will need to be updated for the local governments or entities to allocate resources effectively in managing or upgrading these water points.]{style="color:#d69c3c"}

```{r}
summary(wp_adm$staleness_score > 89)
```

### 3.2.4 Create Master File

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***left_join( )*** - dplyr -]{style="color:#d46e15"} to combine *wp_coord, wp_cond* and *wp_adm.*

```{r}
wp <- left_join(
  
  (left_join
   (wp_coord,wp_cond,
     by = c("row_id")
     )
   ),
  wp_adm, by = c("row_id"))
```

### 3.2.5 Convert Well Known Text (WKT) Data to SF Data Frame

-   The "New Georeferenced Column" in *wp_rds* contains spatial data in a WKT format.

-   Two (2) steps to convert the WKT data format into an sf data frame.

#### 3.2.5.1 derive new field :: "geometry"

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***st_as_sfc( )*** - sf -]{style="color:#d46e15"} to convert foreign geometry object \`New Georeferenced Column\` to an sfc object

```{r}
wp$geometry = st_as_sfc(wp$`New Georeferenced Column`)
```

#### 3.2.5.2 convert to SF Data Frame

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***st_sf( )*** - sf -]{style="color:#d46e15"} to convert the tibble data frame into sf data frame with crs first set to WGS 84 (EPSG : 4326).

[***st_crs( )*** - sf -]{style="color:#d46e15"} to retrieve coordinate reference system from the object.

```{r}
wp_sf<- st_sf(wp, crs = 4326)
st_crs(wp_sf)
```

#### 3.2.5.3 retrieve geometry summary :: *wp_sf*

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***st_geometry( )*** - sf -]{style="color:#d46e15"} to get the geometry summary.

```{r}
st_geometry(wp_sf)
```

## 3.3 Import Boundary Data of Nigeria LGA

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***st_read( )*** - sf -]{style="color:#d46e15"} to read simple features.

[***select( )*** - dplyr -]{style="color:#d46e15"} to select "shapeName" variable.

```{r}
bdy_nga <- st_read(dsn = "/jephOstan/ISSS624/class_project/project_2/data/geospatial",
               layer = "geoBoundaries-NGA-ADM2",
               crs = 4326) %>%
  select(shapeName)

problems(bdy_nga)
```

### 3.3.1 Review Imported File

#### 3.3.1.1 check for missing data

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***freq.na( )*** - questionr -]{style="color:#d46e15"} to generate frequency table of missing value.

```{r}
freq.na(bdy_nga$shapeName)
```

#### 3.3.1.2 check for duplication :: "shapeName"

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***duplicated( )*** - base -]{style="color:#d46e15"} to determine duplicate elements.

```{r}
freq(duplicated(bdy_nga$shapeName))
```

#### 3.3.1.3 list the duplicated value :: "shapeName"

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***add_count( )*** - dplyr -]{style="color:#d46e15"} to count observations by group

[***filter( )*** - dplyr -]{style="color:#d46e15"} to retain shapeName that has count not equal to 1.

```{r}
wp_duplShapeName <- bdy_nga %>%
  add_count(bdy_nga$shapeName) %>%
  filter(n!=1) %>%
  select(-n)

wp_duplShapeName
```

#### 3.3.1.4 verify findings in section 3.3.1.3

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***tmap_mode( )*** - tmap -]{style="color:#d46e15"} to set tmap mode to static plotting or interactive.

[***tm_shape( )*** - tmap -]{style="color:#d46e15"} to specify the shape object.

[***tm_polygons( )*** - tmap -]{style="color:#d46e15"} to fill the polygons and draw the polygon borders.

[***tm_view( )*** - tmap -]{style="color:#d46e15"} to set the options for the interactive tmap viewer.

[***tm_fill( )*** - tmap -]{style="color:#d46e15"} to specify either which colour to be used or which data variable mapped to the colour palette.

[***tm_borders( )*** - tmap -]{style="color:#d46e15"} to draw the polygon borders.

[***tmap_style( )*** - tmap -]{style="color:#d46e15"} to set the tmap style.

[***tm_layout( )*** - tmap -]{style="color:#d46e15"} to set the layout of cartographic map.

```{r}
tmap_mode("view")

tm_shape(bdy_nga)+
  tm_polygons()+
  tm_view(set.zoom.limits = c(6,8))+

tm_shape(wp_duplShapeName)+
  tm_fill("shapeName",
          n = 6,
          style = "jenks")+
  tm_borders(alpha = 0.5)+
  tmap_style("albatross")+
  tm_layout(main.title = "Distribution of Duplicated ShapeName",
            main.title.size = 1.3,
            main.title.position = "center")
```

Remarks :

The plot above indicates those duplicated water points are from different Nigeria states.

```{r}
tmap_mode("plot")
```

#### 3.3.1.5 acquire State info for duplicated value

The State info to be combined with the duplicated "shapeName". This will make all the shapeName unique.

| lga      | row_id | headquarter | state    | iso3166code | state_dd_coordinates                                                      |
|-----------|-----------|-----------|-----------|-----------|--------------------|
| Bassa    | 94     | Oguma       | Kogi     | NG.KO.BA    | [7.75 6.75](https://latitude.to/map/ng/nigeria/regions/kogi-state/)       |
| Bassa    | 95     | Bassa       | Plateau  | NG.PL.BA    | [9.16667 9.75](https://latitude.to/map/ng/nigeria/regions/plateau-state/) |
| Ifelodun | 304    | Share       | Kwara    | NG.KW.IF    | [8.5 5.0](https://latitude.to/map/ng/nigeria/regions/kwara-state/)        |
| Ifelodun | 305    | Ikirun      | Osun     | NG.OS.ID    | [7.5 4.5](https://latitude.to/map/ng/nigeria/regions/osun-state/)         |
| Irepodun | 355    | Omu Aran    | Kwara    | NG.KW.IR    | [8.5 5.0](https://latitude.to/map/ng/nigeria/regions/kwara-state/)        |
| Irepodun | 356    | Ilobu       | Osun     | NG.OS.IP    | [7.5 4.5](https://latitude.to/map/ng/nigeria/regions/osun-state/)         |
| Nasarawa | 519    | Bompai      | Kano     | NG.KN.NA    | [11.5 8.5](https://latitude.to/map/ng/nigeria/regions/kano-state/)        |
| Nasarawa | 520    | Nasarawa    | Nasarawa | NG.NA.NA    | 8.53 7.7                                                                  |
| Obi      | 546    | Obi         | Nasarawa | NG.NA.OB    | 8.53 7.7                                                                  |
| Obi      | 547    | Obarike-Ito | Benue    | NG.BE.OB    | [7.33333 8.75](https://latitude.to/map/ng/nigeria/regions/benue-state/)   |
| Surelere | 693    | Surelere    | Lagos    | NG.LA.SU    | 6.5 3.35                                                                  |
| Surelere | 694    | Iresa-Adu   | Oyo      | NG.OY.SU    | 8.07 4.41                                                                 |

<br>

## 3.4 Data Wrangling

### 3.4.1 Edit Duplicated Value :: "shapeName"

```{r}
bdy_nga$shapeName[c(94,95,304,305,355,356,519,546,547,693,694)] <- 
  c("Bassa Kogi",
    "Bassa Plateau",
    "Ifelodun Kwara",
    "Ifelodun Osun",
    "Irepodun Kwara",
    "Irepodun Osun",
    "Nasarawa Kano",
    "Nasarawa Nasarawa",
    "Obi Nasarawa",
    "Obi Benue",
    "Surulere Lagos",
    "Surulere Oyo")
```

#### 3.4.1.1 validate edited value :: "shapeName"

```{r}
wp_duplShapeName1 <- bdy_nga %>%
  add_count(bdy_nga$shapeName) %>%
  filter(n!=1) %>%
  select(-n)

wp_duplShapeName1
```

### 3.4.2 Perform Point-in-Polygon Overlay

This step combine both attribute and boundary of the water points into a simple feature object.

#### 3.4.2.1 join objects :: *wp_sf* and *bdy_nga*

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***st_join( )*** - sf -]{style="color:#d46e15"} to join *sf*-class objects based on geometry, namely, *wp_sf* and *bdy_nga*.

```{r}
wp_joined <- st_join(x = wp_sf,
                     y = bdy_nga,
                     join = st_intersects,
                     left = TRUE)
```

#### 3.4.2.2 save and read RDS File :: *wp_joined*

```{r}
write_rds(wp_joined,"/jephOstan/ISSS624/class_project/project_2/data/geodata/wp_joined.rds",compress = "xz")

wp_joined <- read_rds("/jephOstan/ISSS624/class_project/project_2/data/geodata/wp_joined.rds")
```

#### 3.4.2.3 inspect joined file :: *wp_joined*

#### \-- retrieve geometry summary

```{r}
st_geometry(wp_joined)
```

#### \-- determine reference point :: "shapeName" or "clean_adm2"

```{r}
wp_refLga <- (wp_joined$shapeName == wp_joined$clean_adm2)
freq(wp_refLga)

```

Remarks :

-   There are 29,713 "FALSE", which is more than 30% of LGA names mismatched between "shapeName" and "clean_adm2".

    -   [Unlike the Water Point Data Exchange data that involved multiple parties, the geoBoundaries data is sourced from "geoBoundaries: A global database of political administrative boundaries." Plos one 15, no. 4 (2020): e0231866,]{style="color:#d69c3c"}

        -   [Hence, the "shapeName" to be used throughout this study.]{style="color:#d69c3c"}

-   The 29 NA's are 29 water points located beyond the LGA boundary, as shown in the plot below.

```{r}
tmap_mode("view")

tm_shape(bdy_nga) +
  tm_polygons() +
  tm_view(set.zoom.limits = c(5.5, 12))+
  
tm_shape(filter(wp_joined, is.na(wp_refLga))) +
  tm_dots(size=0.1,
          col="red")

```

```{r}
tmap_mode("plot")
```

Remove

```{r}
wp_joined2 <- wp_joined %>% filter(shapeName == clean_adm2 | shapeName != clean_adm2)
```

#### \-- assess uniqueness of each Water Point

```{r}
wp_joined %>% janitor::get_dupes(shapeName,lat_lon_deg)
```

Remarks :

Each water point observation is unique as there are no duplicate combination of "shapeName" together with "lat_lon_deg".

#### \-- reveal value :: "status_clean"

```{r}
freq(wp_joined$status_clean)
```

#### \-- reveal value :: "crucialness_score"

```{r}
summary(wp_joined$crucialness_score)
```

#### \-- reveal value :: "is_urban"

```{r}
freq(wp_joined$is_urban)
```

#### \-- reveal value :: "water_tech_category"

```{r}
freq(wp_joined$water_tech_category)
```

#### \-- reveal value :: "usage_capacity"

```{r}
freq(wp_joined$usage_capacity)
```

### 3.4.3 Replace "NA" with "Unknown"

[***mutate( )*** - dplyr -]{style="color:#d46e15"} to run *replace_na( )* function.

-   [***replace_na( )*** - tidyr -]{style="color:#d46e15"} to replace NAs with "unknown".

```{r}
wp_joined1 <- wp_joined %>%
  mutate(status_clean = replace_na(status_clean, "Unknown")) %>%
  mutate(water_tech_category = replace_na(water_tech_category, "Unknown")) %>%
  mutate(status = replace_na(status, "Unknown")) %>%
  mutate(water_point_population = replace_na(water_point_population, 0)) %>%
  mutate(local_population_1km = replace_na(local_population_1km, 0)) %>%
  mutate(crucialness_score = replace_na(crucialness_score, 0)) %>%
  mutate(pressure_score = replace_na(pressure_score, 0))
```

### 3.4.4 Standardise Value

#### 3.4.4.1 combine value :: "status_clean"

```{r}
#| eval: false
wp_joined1 <- wp_joined1 %>%
  mutate(status_clean = str_replace(status_clean,"Non functional due to dry season"  ,"Non-Functional due to dry season")) %>%
  mutate(status_clean = str_replace(status_clean,"Abandoned/Decommissioned/Decommissioned","Abandoned/Decommissioned"))
```

#### 3.4.4.2 review "status_clean"

```{r}
#| eval: false
freq(wp_joined1$status_clean)
```

#### 3.4.4.3 read RDS file :: *wp_joined1*

```{r}
wp_joined1 <- read_rds("/jephOstan/ISSS624/class_project/project_2/data/geodata/wp_joined1.rds")
```

### 3.4.5 Extract Water Point for New Table :: *wp_nga*

#### 3.4.5.1 extract functional water point

```{r}
wpt_functional <- wp_joined1 %>%
  filter(status_clean %in%
           c("Functional", 
             "Functional but not in use",
             "Functional but needs repair"))
```

#### \-- save and read RDS file :: *wpt_functional*

```{r}
write_rds(wpt_functional,"/jephOstan/ISSS624/class_project/project_2/data/geodata/wpt_functional.rds",compress = "xz")

wpt_functional <- read_rds("/jephOstan/ISSS624/class_project/project_2/data/geodata/wpt_functional.rds")
```

#### 3.4.5.2 inspect variable and value

#### \-- reveal value :: "status_clean"

```{r}
freq(wpt_functional$status_clean)

length(wpt_functional$row_id)
length(wpt_functional$row_id)/length(wp_joined1$row_id)*100
```

Remarks :

The total functional water points is 52,148 which is about 54.89% of total water points.

#### \-- reveal value :: "usage_capacity"

```{r}
freq(wpt_functional$usage_capacity)
```

#### \-- reveal value "usage_capacity" by "status_clean"

```{r}
wpt_functional %>% count(status_clean, usage_capacity, sort = TRUE)

```

#### \-- reveal value :: "crucialness_score"

```{r}
summary(wpt_functional$crucialness_score == 1)
```

#### \-- determine the total population within 1 km by "crucialness_score"

```{r}
freq(wpt_functional$crucialness_score == 1)
sum(wpt_functional[wpt_functional$crucialness_score == 1,]$local_population_1km)
```

Remarks :

Given the "crucialness_score" is a ratio of current water point users to the total population within 1 km radius thereof :

-   [Currently, 5,142 water points serve the population within a 1 km radius at its capacity limit.]{style="color:#d69c3c"}

    -   [The usage capacity may need to be increased to sustain or improve the growth or development rate within 1km of these water points.]{style="color:#d69c3c"}

    -   [Should the population within 1 km therefrom grow above 11,252,574, there may be multiple repercussions in resources management, urbanisation progress, local food and beverage consumption, local commodity prices, or worst case scenario would be the stability of civil society.]{style="color:#d69c3c"}

```{r}
summary(wpt_functional$pressure_score > 1)

length(wpt_functional$pressure_score)

24679/52148*100 #percentage of functional waterpoints over their usage limit
```

Remarks :

Given the "pressure_score" is the ratio of the current water point users to the usage capacity thereof :

-   [24,679, or 47.32% of functional water points, are currently over their limit of usage capacity.]{style="color:#d69c3c"}

#### 3.4.5.3 Exploratory Data Analysis (EDA) :: *wpt_functional*

#### \-- plot "status_clean"

```{r}
ggplot(data = wpt_functional,
       aes(fct_infreq(status_clean), fill=status_clean))+ 
  geom_bar()+
  geom_text(
     aes(label=after_stat(count)),
     stat='count',
     nudge_x=-0.25,
     vjust=-0.2)+
  geom_text(
     aes(label= scales::percent(signif(after_stat(count/sum(count))))),
     stat='count',
     nudge_x=0.25,
     vjust=-0.2)+
  scale_x_discrete(guide = guide_axis(n.dodge = 2))+
  guides(fill=guide_legend (title = 'Status'))
```

#### \-- plot "water_tech_category"

```{r}
ggplot(data=wpt_functional, 
       aes(x=fct_infreq(
         water_tech_category)))+
  geom_bar(aes(
    fill = water_tech_category), 
    width = 0.8)+
  geom_text(aes(
    label = ..count..),
    stat = "count", 
    vjust=-0.2, 
    size = 3.5, 
    color = "black")+
  scale_x_discrete(guide = guide_axis(n.dodge = 2))+
  guides(fill=guide_legend (title = 'Water Tech Deployed'))
```

#### \-- plot "water_source_clean"

```{r}
ggplot(data=wpt_functional, 
       aes(x=fct_infreq(
         water_source_clean)))+
  geom_bar(aes(
    fill = water_source_clean), 
    width = 0.8)+
  geom_text(aes(
    label = ..count..),
    stat = "count", 
    vjust=-0.2, 
    size = 3.5, 
    color = "black")+
  scale_x_discrete(guide = guide_axis(
    n.dodge = 2))+
  guides(fill=guide_legend (
    title = 'Source of Water Supply'))
```

#### 3.4.5.4 add attribute to new data table

```{r}
wp_nga <- bdy_nga %>%
  mutate(`total_wp` = lengths(
    st_intersects(bdy_nga, wp_joined1))) %>%
  
  mutate(`wp_functional` = lengths(
    st_intersects(bdy_nga, wpt_functional))) %>%
  
  mutate(`pct_functional` = (`wp_functional`/`total_wp`*100))
```

#### \-- replace "NaN" with 0

```{r}
wp_nga <- wp_nga %>%
  mutate(`pct_functional` = replace_na(pct_functional, 0))

summary(wp_nga)
```

#### 3.4.5.5 extract non-functional water point

```{r}
wpt_nonFunctional <- wp_joined1 %>%
  filter(status_clean %in%
           c("Abandoned/Decommissioned", 
             "Non-Functional",
             "Non-Functional due to dry season"))
```

#### \-- save and read RDS file :: *wpt_nonFuntional*

```{r}
write_rds(wpt_nonFunctional,"/jephOstan/ISSS624/class_project/project_2/data/geodata/wpt_nonFunctional.rds",compress = "xz")

wpt_nonFunctional <- read_rds("/jephOstan/ISSS624/class_project/project_2/data/geodata/wpt_nonFunctional.rds")
```

#### 3.4.5.6 inspect variable and value

\-- reveal value :: "status_clean"

```{r}
freq(wpt_nonFunctional$status_clean)

length(wpt_nonFunctional$row_id)
length(wpt_nonFunctional$row_id)/length(wp_joined1$row_id)*100
```

Remarks :

There are 32,204, which is about 33.9% out of total water points.

#### \-- reveal value :: "usage_capacity"

```{r}
freq(wpt_nonFunctional$usage_capacity)
```

#### \-- reveal value "usage_capacity" by "status_clean"

```{r}
wpt_nonFunctional %>% count(status_clean, usage_capacity, sort = TRUE)
```

#### \-- reveal "crucialness_score"

```{r}
sum(wpt_nonFunctional$local_population_1km)
sum(wpt_nonFunctional$water_point_population)
```

Remarks :

Given the "crucialness_score" is a ratio of current water point users to the total population within a 1 km radius thereof , in the context of non-functional :

-   [Currently, out of 95,013,340 residents within a 1 km radius, there are 46,710,127 of them is affected by these non-functional water point.]{style="color:#d69c3c"}

#### 3.4.5.7 EDA :: *wpt_nonFunctional*

#### \-- plot "status_clean"

```{r}
ggplot(data = wpt_nonFunctional,
       aes(fct_infreq(status_clean), 
           fill=status_clean))+ 
  geom_bar()+
  geom_text(
     aes(label=after_stat(count)),
     stat='count',
     nudge_x=-0.25,
     vjust=-0.2)+
  geom_text(
     aes(label= scales::percent(
       signif(
         after_stat(
           count/sum(count)
           )))),
     stat='count',
     nudge_x=0.25,
     vjust=-0.2)+
  scale_x_discrete(
    guide = guide_axis(
      n.dodge = 2))+
  guides(fill=guide_legend (
    title = 'Status'))
```

#### \-- plot "water_tech_category"

```{r}
ggplot(data=wpt_nonFunctional, 
       aes(fct_infreq(
         water_tech_category)))+
  geom_bar(aes(
    fill = water_tech_category), 
    width = 0.8)+
  geom_text(aes(
    label = ..count..),
    stat = "count",
    vjust=-0.2,
    size = 3.5,
    color = "black")+
  scale_x_discrete(guide = guide_axis(
    n.dodge = 2))+
  guides(fill=guide_legend (
    title = 'Water Tech Deployed'))
```

#### \-- plot "water_source_clean"

```{r}
ggplot(data=wpt_nonFunctional, 
       aes(fct_infreq(
         water_source_clean)))+
  geom_bar(aes(
    fill = water_source_clean),
    width = 0.8)+
  geom_text(aes(
    label = ..count..),
    stat = "count",
    vjust=-0.2,
    size = 3.5,
    color = "black")+
  scale_x_discrete(guide = guide_axis(
    n.dodge = 2))+
  guides(fill=guide_legend (
    title = 'Source of Water Supply'))
```

#### 3.4.5.8 add *wpt_nonFunctional* to *wp_nga*

```{r}
wp_nga <- wp_nga %>%
  mutate(`wp_nonFunctional` = lengths(
    st_intersects(bdy_nga, wpt_nonFunctional))) %>%
  mutate(`pct_nonFunctional` = (`wp_nonFunctional`/`total_wp`*100))
```

#### \-- replace "NaN" with 0

```{r}
wp_nga <- wp_nga %>%
  mutate(`pct_nonFunctional` = replace_na(pct_nonFunctional, 0))

summary(wp_nga)
```

#### 3.4.5.9 extract unknown water point

```{r}
wpt_unknown <- wp_joined1 %>%
  filter(status_clean == "Unknown")
```

#### \-- save and read RDS file :: *wpt_unknown*

```{r}
write_rds(wpt_unknown,"/jephOstan/ISSS624/class_project/project_2/data/geodata/wpt_unknown.rds")

wpt_unknown <- read_rds("/jephOstan/ISSS624/class_project/project_2/data/geodata/wpt_unknown.rds")
```

#### 3.4.5.10 inspect variable and value

#### \-- reveal value :: "status_clean"

```{r}
length(wpt_unknown$row_id)

length(wpt_unknown$row_id)/length(wp_joined1$row_id)*100
```

Remarks :

There are 10,656 water points with unknown status, about 11.22% of total water points.

#### \-- determine affected population

```{r}
sum(wpt_unknown$water_point_population)
sum(wpt_unknown$local_population_1km)
```

#### 3.4.5.11 add *wpt_unknown* to *wp_nga*

```{r}
wp_nga <- wp_nga %>%
  mutate(`wp_unknown` = lengths(
    st_intersects(bdy_nga, wpt_unknown))) %>%
  mutate(`pct_unknown` = (`wp_unknown`/`total_wp`*100))
```

#### \-- replace "NaN" with 0

```{r}
wp_nga <- wp_nga %>%
  mutate(`pct_unknown` = replace_na(pct_unknown, 0))

summary(wp_nga)
```

#### 3.4.5.12 visualise distribution :: "status_clean"

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***qtm( )*** - tmap -]{style="color:#d46e15"} to plot a thematic map quickly.

[***tmap_arrange( )*** - tmap -]{style="color:#d46e15"} to arrange small multiples in grid layout.

```{r}
total_wp <- qtm(wp_nga,"total_wp")+
  tm_layout(legend.height = 0.3, legend.width = 0.5)

wp_functional <- qtm(wp_nga,"wp_functional")+
  tm_layout(legend.height = 0.3, legend.width = 0.5)

wp_nonFunctional <- qtm(wp_nga,"wp_nonFunctional")+
  tm_layout(legend.height = 0.3, legend.width = 0.5)

wp_unknown <- qtm(wp_nga,"wp_unknown")+
  tm_layout(legend.height = 0.3, legend.width = 0.5)

tmap_arrange(total_wp, wp_functional, wp_nonFunctional, wp_unknown, asp=0, ncol = 2, nrow = 2, widths = 5, heights = 10, sync = TRUE)
```

#### 3.4.5.13 extract "water_tech_category" to *wp_nga*

```{r}
freq(wp_joined1$water_tech_category, sort = "dec")
```

Remarks :

Only "Hand Pump", "Mechanized Pump", and "Tapstand" are to be extracted for further analysis as the rest are either less than 0.5% or "Unknown".

```{r}
wtc_hPump <- wp_joined1 %>%
  filter(water_tech_category %in%
           "Hand Pump")

wtc_mPump <- wp_joined1 %>%
  filter(water_tech_category %in%
           "Mechanized Pump")

wtc_tStand <- wp_joined1 %>%
  filter(water_tech_category %in%
           "Tapstand")

wp_nga <- wp_nga %>%
  mutate(`total_handPump` = lengths(
    st_intersects(bdy_nga, wtc_hPump)
  )) %>%
  mutate(`total_mechPump` = lengths(
    st_intersects(bdy_nga, wtc_mPump)
  )) %>%
    mutate(`total_tapStand` = lengths(
    st_intersects(bdy_nga, wtc_tStand)
  )) %>%
  mutate(`pct_handPump` = (`total_handPump`/`total_wp`*100)) %>%
  mutate(`pct_mechPump` = (`total_mechPump`/`total_wp`*100)) %>%
  mutate(`pct_tapStand` = (`total_tapStand`/`total_wp`*100))
```

#### \-- replace "NaN" with 0

```{r}
wp_nga <- wp_nga %>%
  mutate(`pct_handPump` = replace_na(pct_handPump, 0)) %>%
  mutate(`pct_mechPump` = replace_na(pct_mechPump, 0)) %>%
  mutate(`pct_tapStand` = replace_na(pct_tapStand, 0))

summary(wp_nga)
```

#### 3.4.5.14 visualise *wp_nga* distribution :: "water_tech_category"

```{r}
handPump <- tm_shape(bdy_nga)+
  tm_polygons(alpha = 0.1) +
tm_shape(wp_nga) +  
  tm_dots(col = "pct_handPump",
          border.col = "gray60",
          border.lwd = 0.5) +
  tm_view(set.zoom.limits = c(5,9))

mechPump <- tm_shape(bdy_nga)+
  tm_polygons(alpha = 0.1) +
tm_shape(wp_nga) +  
  tm_dots(col = "pct_mechPump",
          border.col = "gray60",
          border.lwd = 0.5) +
  tm_view(set.zoom.limits = c(5,9))

tapStand <- tm_shape(bdy_nga)+
  tm_polygons(alpha = 0.1) +
tm_shape(wp_nga) +  
  tm_dots(col = "pct_tapStand",
          border.col = "gray60",
          border.lwd = 0.5) +
  tm_view(set.zoom.limits = c(5,9))

tmap_arrange(handPump, mechPump, tapStand,
             asp=1, 
             ncol=2,
             sync = TRUE)
```

#### 3.4.5.15 extract "usage_capacity" to *wp_nga*

```{r}
freq(wp_joined1$usage_capacity, sort = "dec")
```

Remarks :

-   Only "300", "1000", and "250" are to be extracted for further analysis as the rest are either less than 0.5% or "Unknown".

-   But, "50" will be included in the new variable "total_ucN1000" as part of the none '1000' "usage_capacity" value.

```{r}
uCap_300 <- wp_joined1 %>%
  filter(usage_capacity %in%
           "300")

uCap_1000 <- wp_joined1 %>%
  filter(usage_capacity %in%
           "1000")

uCap_250 <- wp_joined1 %>%
  filter(usage_capacity %in%
           "250")

uCap_50 <- wp_joined1 %>%
  filter(usage_capacity %in%
           "50")

wp_nga <- wp_nga %>%
  mutate(`total_uc300` = lengths(
    st_intersects(bdy_nga, uCap_300)
  )) %>%
  mutate(`total_uc1000` = lengths(
    st_intersects(bdy_nga, uCap_1000)
  )) %>%
  mutate(`total_uc250` = lengths(
    st_intersects(bdy_nga, uCap_250)
  )) %>%
  mutate(`total_uc50` = lengths(
    st_intersects(bdy_nga, uCap_50)
  )) %>%
  mutate(`total_ucN1000` = ((lengths(
    st_intersects(
      bdy_nga, uCap_300))) + (lengths(
        st_intersects(
          bdy_nga, uCap_250))) + (lengths(
            st_intersects(
              bdy_nga, uCap_50))))
    )%>%
           
  mutate(`pct_ucN1000` = (`total_ucN1000`/`total_wp`*100)) %>%
  mutate(`pct_uc300` = (`total_uc300`/`total_wp`*100)) %>%
  mutate(`pct_uc1000` = (`total_uc1000`/`total_wp`*100)) %>%
  mutate(`pct_uc250` = (`total_uc250`/`total_wp`*100))
```

#### \-- replace "NaN" with 0

```{r}
wp_nga <- wp_nga %>%
  mutate(`pct_ucN1000` = replace_na(pct_ucN1000, 0)) %>%
  mutate(`pct_uc300` = replace_na(pct_uc300, 0)) %>%
  mutate(`pct_uc1000` = replace_na(pct_uc1000, 0)) %>%
  mutate(`pct_uc250` = replace_na(pct_uc250, 0))

summary(wp_nga)
```

#### 3.4.5.16 visualise *wp_nga* distribution :: "usage_capacity"

```{r}
uc300 <- tm_shape(bdy_nga)+
  tm_polygons(alpha = 0.1) +
tm_shape(wp_nga) +  
  tm_dots(col = "pct_uc300",
          border.col = "gray60",
          border.lwd = 0.5) +
  tm_view(set.zoom.limits = c(5,9))

uc1000 <- tm_shape(bdy_nga)+
  tm_polygons(alpha = 0.1) +
tm_shape(wp_nga) +  
  tm_dots(col = "pct_uc1000",
          border.col = "gray60",
          border.lwd = 0.5) +
  tm_view(set.zoom.limits = c(5,9))

uc250 <- tm_shape(bdy_nga)+
  tm_polygons(alpha = 0.1) +
tm_shape(wp_nga) +  
  tm_dots(col = "pct_uc250",
          border.col = "gray60",
          border.lwd = 0.5) +
  tm_view(set.zoom.limits = c(5,9))

tmap_arrange(uc300, uc1000, uc250,
             asp=1, 
             ncol=2,
             sync = TRUE)
```

#### 3.4.5.17 extract "is_urban" to *wp_nga*

```{r}
urban_1 <- wp_joined1 %>%
  filter(is_urban %in%
           "TRUE")

urban_0 <- wp_joined1 %>%
  filter(is_urban %in%
           "FALSE")

wp_nga <- wp_nga %>%
  mutate(`total_urban1` = lengths(
    st_intersects(bdy_nga, urban_1)
  )) %>%
  mutate(`total_urban0` = lengths(
    st_intersects(bdy_nga, urban_0)
  )) %>%
  mutate(`pct_urban1` = (`total_urban1`/`total_wp`*100)) %>%
  mutate(`pct_urban0` = (`total_urban0`/`total_wp`*100))
```

#### \-- replace "NaN" with 0

```{r}
wp_nga <- wp_nga %>%
  mutate(`pct_urban1` = replace_na(pct_urban1, 0)) %>%
  mutate(`pct_urban0` = replace_na(pct_urban0, 0))

summary(wp_nga)
```

#### 3.4.5.18 visualise *wp_nga* distribution :: "is_urban"

```{r}
urban1 <- tm_shape(bdy_nga)+
  tm_polygons(alpha = 0.1) +
tm_shape(wp_nga) +  
  tm_dots(col = "pct_urban1",
          border.col = "gray60",
          border.lwd = 0.5) +
  tm_view(set.zoom.limits = c(5,9))

urban0 <- tm_shape(bdy_nga)+
  tm_polygons(alpha = 0.1) +
tm_shape(wp_nga) +  
  tm_dots(col = "pct_urban0",
          border.col = "gray60",
          border.lwd = 0.5) +
  tm_view(set.zoom.limits = c(5,9))

tmap_arrange(urban1, urban0,
             asp=1, 
             ncol=2,
             sync = TRUE)
```

<br>

#### 3.4.5.19 save and read RDS File :: *wp_nga*

```{r}
write_rds(wp_nga,"/jephOstan/ISSS624/class_project/project_2/data/geodata/wp_nga.rds")
wp_nga <- read_rds("/jephOstan/ISSS624/class_project/project_2/data/geodata/wp_nga.rds")
```

#### 3.4.5.20 transform to Projected Coordinate System

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***st_crs( )*** - sf -]{style="color:#d46e15"} to inspect the coordinate reference system.

```{r}
st_crs(wp_nga)
```

Remarks :

The EPSG for *wp_nga* is 4326, which is WGS 84. To compute the proximity distance matrix for clustering analysis, this coordinate reference system needs to transform into EPSG: 26391.

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***st_set_crs( )*** - sf -]{style="color:#d46e15"} to update the coordinate reference system.

```{r}
wp_ngaTrans <- st_set_crs(wp_nga, 26391)
bdy_ngaTrans <- st_set_crs(bdy_nga, 26391)
```

#### \-- review CRS :: *wp_ngaTrans*

```{r}
st_crs(wp_ngaTrans)
```

\-- review CRS :: bdy_ngaTrans

```{r}
st_crs(bdy_ngaTrans)
```

## 3.5 Exploratory Data Analysis

### 3.5.1 Identify Outliers

#### 3.5.1.1 plot boxplot "pct_functional"

```{r}
ggplot(data=wp_ngaTrans, 
       aes(x=`pct_functional`)) +
  geom_boxplot(color="black", 
               fill="#543005")
```

### 3.5.1.2 plot boxplot "pct_nonFunctional"

```{r}
ggplot(data=wp_ngaTrans, 
       aes(x=`pct_nonFunctional`)) +
  geom_boxplot(color="black", 
               fill="#C16622FF")
```

### 3.5.1.3 plot boxplot "pct_unknown"

```{r}
ggplot(data=wp_ngaTrans, 
       aes(x=`pct_unknown`)) +
  geom_boxplot(color="black", 
               fill="#FFA319FF")
```

Remarks :

Among these 3 key categories of "status_clean", "unknown" has the most outliers.

### 3.5.2 Multi-plot Histogram

#### 3.5.2.1 plot histogram for "status_clean"

```{r}
pctFunctional <- ggplot(data = wp_ngaTrans,
                         aes(x = `pct_functional`))+
  geom_histogram(bins=10,
                 colour = "black",
                 fill = "#543005")

pctNonFunctional <- ggplot(data = wp_ngaTrans,
                         aes(x = `pct_nonFunctional`))+
  geom_histogram(bins=10,
                 colour = "black",
                 fill = "#C16622FF")

pctUnknown <- ggplot(data = wp_ngaTrans,
                     aes(x = `pct_unknown`))+
  geom_histogram(bins = 10,
                 colour = "black",
                 fill = "#FFA319FF")
```

```{r}
ggarrange(pctFunctional,pctNonFunctional,pctUnknown,
          ncol = 2,
          nrow = 2)
```

# 4. CORRELATION ANALYSIS

## 4.1 Create Data Table for Correlation Matrix Analysis

```{r}
cluster_vars <- wp_ngaTrans %>%
  st_set_geometry(NULL) %>%
  select("shapeName",
         "pct_functional", 
         "pct_nonFunctional",
         "pct_unknown", 
         "pct_handPump",
         "pct_mechPump",
         "pct_tapStand",
         "pct_uc300",
         "pct_uc1000",
         "pct_ucN1000",
         "pct_uc250",
         "pct_urban0")
head(cluster_vars,5)
```

## 4.2 Visualise Correlation Matrix

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***corrplot.mixed( )*** - corrplot -]{style="color:#d46e15"} to use mixed methods to visualise a correlation matrix.

This plot allows to identify the pattern and the relationship in the matrix.

```{r}
corrplot.mixed((cor(cluster_vars[,2:12])),
               upper = "number",
               lower = "ellipse",
               tl.col = "black",
               diag = "l",
               tl.pos = "lt")
```

Remarks :

Following are the pairs with strong correlation :

| correlation coefficients |  variable_1  | variable_2  |
|:------------------------:|:------------:|:-----------:|
|           1.00           | pct_mechPump | pct_uc1000  |
|           0.99           | pct_tapStand |  pct_uc250  |
|           0.99           |  pct_uc300   | pct_ucN1000 |
|          -0.91           | pct_mechPump | pct_ucN1000 |
|          -0.91           |  pct_uc1000  | pct_ucN1000 |
|          -0.90           | pct_mechPump |  pct_uc300  |
|          -0.90           |  pct_uc300   | pct_uc1000  |

### 4.2.1 Replace Row ID with "shapeName"

```{r}
row.names(cluster_vars) <- cluster_vars$shapeName
```

### 4.2.2 Trim High Correlation Variable and "shapeName"

```{r}
cluster_varsTrim <- cluster_vars %>%
  select(-shapeName, -pct_ucN1000, -pct_mechPump)
```

#### 4.2.2.1 review trimmed data table

```{r}
summary(cluster_varsTrim)
```

# 5. CLUSTERING ANALYSIS

## 5.1 Hierarchy Clustering

There are [four (4) main steps](https://www.learndatasci.com/glossary/hierarchical-clustering/) :

-   compute proximity matrix.
-   assign data point to a cluster.
-   merge clusters based on similarity between clusters.
-   update the distance matrix.

### 5.1.1 Standardise Data

As shown in the 4.2.3.1, there are few variables with Max. different from others. Hence, standardisation will be required prior to further analysis.

#### 5.1.1.1 standardise with min-max method

```{r}
nga_wpStd <- normalize(cluster_varsTrim)
summary(nga_wpStd)
```

#### 5.1.1.2 standardise with Z-score method

```{r}
nga_wpZ <- scale(cluster_varsTrim)
describe(nga_wpZ)
```

#### 5.1.1.3 visualise distribution of standardised clustering variable

#### \-- functional water point

```{r}
fwp <- ggplot(data=cluster_varsTrim, 
             aes(x= `pct_functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="steelblue") +
  ggtitle("Before Standardisation")


fwp_stdDf <- as.data.frame(nga_wpStd)
fwp_std <- ggplot(data=fwp_stdDf, 
       aes(x=`pct_functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="steelblue") +
  ggtitle("Min-Max Stdsn.")

fwp_zDf <- as.data.frame(nga_wpZ)
fwp_z <- ggplot(data=fwp_zDf, 
       aes(x=`pct_functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="steelblue") +
  ggtitle("Z-score Stdsn.")

ggarrange(fwp, fwp_std, fwp_z,
          ncol = 3,
          nrow = 1)
```

```{r}
fwp <- ggplot(data=cluster_varsTrim, 
             aes(x= `pct_functional`)) +
  geom_density(color="black", 
                 fill="steelblue") +
  ggtitle("Before Standardisation")


fwp_stdDf <- as.data.frame(nga_wpStd)
fwp_std <- ggplot(data=fwp_stdDf, 
       aes(x=`pct_functional`)) +
  geom_density(color="black", 
                 fill="steelblue") +
  ggtitle("Min-Max Stdsn.")

fwp_zDf <- as.data.frame(nga_wpZ)
fwp_z <- ggplot(data=fwp_zDf, 
       aes(x=`pct_functional`)) +
  geom_density(color="black", 
                 fill="steelblue") +
  ggtitle("Z-score Stdsn.")

ggarrange(fwp, fwp_std, fwp_z,
          ncol = 3,
          nrow = 1)
```

#### \-- water point deployed with handpump

```{r}
HP <- ggplot(data=cluster_varsTrim, 
             aes(x= `pct_handPump`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="steelblue") +
  ggtitle("Before Standardisation")


fwp_stdDf <- as.data.frame(nga_wpStd)
HP_std <- ggplot(data=fwp_stdDf, 
       aes(x=`pct_handPump`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="steelblue") +
  ggtitle("Min-Max Stdsn.")

fwp_zDf <- as.data.frame(nga_wpZ)
HP_z <- ggplot(data=fwp_zDf, 
       aes(x=`pct_handPump`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="steelblue") +
  ggtitle("Z-score Stdsn.")

ggarrange(HP, HP_std, HP_z,
          ncol = 3,
          nrow = 1)
```

```{r}
HP <- ggplot(data=cluster_varsTrim, 
             aes(x= `pct_handPump`)) +
  geom_density(color="black", 
                 fill="steelblue") +
  ggtitle("Before Standardisation")


fwp_stdDf <- as.data.frame(nga_wpStd)
HP_std <- ggplot(data=fwp_stdDf, 
       aes(x=`pct_handPump`)) +
  geom_density(color="black", 
                 fill="steelblue") +
  ggtitle("Min-Max Stdsn.")

fwp_zDf <- as.data.frame(nga_wpZ)
HP_z <- ggplot(data=fwp_zDf, 
       aes(x=`pct_handPump`)) +
  geom_density(color="black", 
                 fill="steelblue") +
  ggtitle("Z-score Stdsn.")

ggarrange(HP, HP_std, HP_z,
          ncol = 3,
          nrow = 1)
```

#### \-- water point with 1000 users usage capacity

```{r}
uc1000 <- ggplot(data=cluster_varsTrim, 
             aes(x= `pct_uc1000`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="steelblue") +
  ggtitle("Before Standardisation")

fwp_stdDf <- as.data.frame(nga_wpStd)
uc1000_std <- ggplot(data=fwp_stdDf, 
       aes(x=`pct_uc1000`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="steelblue") +
  ggtitle("Min-Max Stdsn.")

fwp_zDf <- as.data.frame(nga_wpZ)
uc1000_z <- ggplot(data=fwp_zDf, 
       aes(x=`pct_uc1000`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="steelblue") +
  ggtitle("Z-score Stdsn.")

ggarrange(uc1000, uc1000_std, uc1000_z,
          ncol = 3,
          nrow = 1)
```

```{r}
uc1000 <- ggplot(data=cluster_varsTrim, 
             aes(x= `pct_uc1000`)) +
  geom_density(color="black", 
                 fill="steelblue") +
  ggtitle("Before Standardisation")


fwp_stdDf <- as.data.frame(nga_wpStd)
uc1000_std <- ggplot(data=fwp_stdDf, 
       aes(x=`pct_uc1000`)) +
  geom_density(color="black", 
                 fill="steelblue") +
  ggtitle("Min-Max Stdsn.")

fwp_zDf <- as.data.frame(nga_wpZ)
uc1000_z <- ggplot(data=fwp_zDf, 
       aes(x=`pct_uc1000`)) +
  geom_density(color="black", 
                 fill="steelblue") +
  ggtitle("Z-score Stdsn.")

ggarrange(uc1000, uc1000_std, uc1000_z,
          ncol = 3,
          nrow = 1)
```

### 5.1.2 Compute Proximity Matrix

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***dist( )*** - stats -]{style="color:#d46e15"} to compute the proximity distance matrix. Among **euclidean, maximum, manhattan, canberra, binary and minkowski**, *euclidean* is used to compute *proxmat_euc.*

```{r}
proxmat_euc <- dist(cluster_varsTrim, method = 'euclidean')
```

### 5.1.3 Compute Hierarchical Clustering

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***hclust( )*** - stats -]{style="color:#d46e15"} to compute cluster with agglomeration method.

[***ggdendrogram( )*** - ggdendro -]{style="color:#d46e15"} to plot dendrogram with tools available in [ggplot2]{style="color:#d46e15"}.

```{r}
hieClust_warD <- hclust(proxmat_euc, method = 'ward.D')
ggdendrogram(hieClust_warD, 
             rotate = TRUE, 
             size = 2, 
             theme_dendro = FALSE)
```

### 5.1.4 Determine Optimal Clustering Algorithm

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***agnes( )*** - cluster -]{style="color:#d46e15"} to get agglomerative coefficient of 4 clustering structure, namely "average", "single", "complete" and "ward".

```{r}
m <- c( "average", "single", "complete", "ward")

names(m) <- c( "average", "single", "complete", "ward")

ac <- function(x) {
  agnes(cluster_varsTrim, method = x)$ac
  }

map_dbl(m, ac)
```

Remarks :

-   Value 1 indicate strongest clustering structure.

-   Ward's method provides the strongest clustering structure. Therefore, Ward's method to be used in subsequent analysis.

### 5.1.5 Determine Optimal Clusters

To determine the optimal clusters to retain, following commons methods are tested :

-   Gap statistic

-   Elbow

-   Average Silhouette

#### 5.1.5.1 compute Gap Statistic method

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***clusGap( )*** - cluster -]{style="color:#d46e15"} to compute the gap statistic.

```{r}
set.seed(12345)
gap_stat <- clusGap(cluster_varsTrim, 
                    FUN = hcut, 
                    nstart = 25, 
                    K.max = 30, 
                    B = 50)
# Print the result
print(gap_stat, method = "firstmax")
```

#### \-- visualise *gap_stat*

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***fviz_nbclust( )*** - factoextra -]{style="color:#d46e15"} to compute and visualise the Optimal Number of clusters.

```{r}
set.seed(12345)
fviz_nbclust(nga_wpZ, 
             kmeans, 
             nstart = 25,  
             method = "gap_stat", 
             nboot = 50)+
  labs(subtitle = "Gap statistic method")
```

#### 5.1.5.2 compute and visualise Elbow method

```{r}
fviz_nbclust(nga_wpZ, kmeans, method = "wss") +
    geom_vline(xintercept = 4, linetype = 2)+
  labs(subtitle = "Elbow method")
```

#### 5.1.5.3 compute and visualise Silhouette method

```{r}
fviz_nbclust(nga_wpZ, kmeans, method = "silhouette")+
  labs(subtitle = "Silhouette method")
```

Remarks :

Given the Elbow method, Silhouette method and Gap Statistic method, the 5-cluster by Silhouette method will be used for the rest of the study.

#### 5.1.5.4 interpret with Dendrogram

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***rect.hclust( )*** - stats -]{style="color:#d46e15"} to draw the dendrogram with a border around the selected clusters.

```{r}
plot(hieClust_warD, cex = 0.6)
rect.hclust(hieClust_warD, 
            k = 5, 
            border = 2:5)
```

### 5.1.6 Visually-Driven Hierarchical Clustering Analysis

The data is loaded into a data frame, but it has to be a data matrix to plot the heatmap. Hence, the data frame will need to first transform into a matrix.

#### 5.1.6.1 transform data frame into matrix

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***data.matrix( )*** - base -]{style="color:#d46e15"} to transform *cluster_varsTrim* data frame into a data matrix, and named it as *nga_clustMat*.

```{r}
nga_clustMat <- data.matrix(cluster_varsTrim)
```

#### 5.1.6.2 plot interactive cluster heatmap

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***heatmaply( )*** - heatmaply -]{style="color:#d46e15"} to build an interactive cluster heatmap.

```{r}
heatmaply(normalize(nga_clustMat),
          Colv=NA,
          dist_method = "euclidean",
          hclust_method = "ward.D",
          seriate = "OLO",
          colors = Blues,
          k_row = 5,
          margins = c(NA,200,60,NA),
          fontsize_row = 4,
          fontsize_col = 5,
          main="Geographic Segmentation of Nigeria by Water Points",
          xlab = "Water Points",
          ylab = "Nigeria LGA"
          )
```

Remarks :

Based on the plot above, 5 clusters to be retained for further analysis.

#### 5.1.6.3 map the formed cluster

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***cutree( )*** - base -]{style="color:#d46e15"} to derive a 5-cluster model, and named the output as *groups*.

```{r}
groups <- as.factor(cutree(hieClust_warD, k=5))
```

#### 5.1.6.4 append *groups* to *wp_ngaTrans*

```{r}
nga_clust.sf <- cbind(wp_ngaTrans, as.matrix(groups)) %>%
  rename(`cluster`=`as.matrix.groups.`)
```

5.1.6.5 plot choropleth map :: *nga_clust.sf*

```{r}
qtm(nga_clust.sf, "cluster")
```

Remarks :

The choropleth map above shows the fragmented clusters by the used of non-spatial clustering algorithm (hierarchical cluster analysis method).

## 5.2 Spatially Constrained Clustering :: SKATER Approach

SKATER function only support sp objects in SpatialPolygonDataFrame. Hence, the *wp_ngaTrans* has to first transform into SpatialPolygonDataFrame before proceed further.

### 5.2.1 Convert SF to SP Data Frame

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***as_Spatial( )*** - sf -]{style="color:#d46e15"} to convert *wp_ngaTrans* into *nga_sp* in a SP data frame.

```{r}
nga.sp <- as_Spatial(wp_ngaTrans)
```

### 5.2.2 Compute Neighbour List

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***poly2nb( )*** - spdep -]{style="color:#d46e15"} to compute the neighbours list from polygon list.

```{r}
nga.nb <- poly2nb(nga.sp, queen = TRUE)
summary(nga.nb)
```

Remarks :

There is one (1) region, i.e. #86 is without link. It has to be removed first before proceed to plot the neighbours list.

#### 5.2.2.1 remove 0-neighbour region

```{r}
wp_ngaTrans1 <- wp_ngaTrans[-86,]
cluster_varsTrim1 <- cluster_varsTrim[-86,]
nga_clust.sf1 <- nga_clust.sf[-86,]
nga_wpZ1 <- nga_wpZ[-86,]
nga.sp1 <- as_Spatial(wp_ngaTrans1)

nga.nb1 <- poly2nb(nga.sp1)
summary(nga.nb1)
```

#### 5.2.2.2 plot Neighbour List by Centroid Node

[Usage of the code chunk below :]{style="color:#5e5c5c"} plot the boundary first before the neighbour list object to avoid any region from being clipped away.

```{r}
plot(nga.sp1, 
     border=grey(.5))
plot(nga.nb1, 
     coordinates(nga.sp1), 
     col="blue", 
     add=TRUE)
```

### 5.2.3 Compute Minimum Spanning Tree (MST)

#### 5.2.3.1 calculate edge costs

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***nbcosts( )*** - spdep -]{style="color:#d46e15"} to compute the cost of each edge which is the distance between nodes.

```{r}
edge_cost <- nbcosts(nga.nb1, cluster_varsTrim1)
```

#### 5.2.3.2 specify spatial weight

[***nb2listw( )*** - spdep -]{style="color:#d46e15"} to specify *edge_cost* as the spatial weights. Set the "style" to "B" to ensure the cost values are not row-standardised.

```{r}
nga.w <- nb2listw(nga.nb1,
                  edge_cost,
                  style = "B")
summary(nga.w)
```

#### 5.2.3.3 compute minimum spanning tree

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***nbcosts( )*** - spdep -]{style="color:#d46e15"} to compute the minimum spanning tree.

```{r}
nga_minSpanT <- mstree(nga.w)
```

#### \-- review class and dimension of the computed MST

```{r}
class(nga_minSpanT)
```

```{r}
dim(nga_minSpanT)
```

```{r}
head(nga_minSpanT)
```

#### 5.2.3.4 plot MST Neighbour List

```{r}
plot(nga.sp1, border=gray(.5))
plot.mst(nga_minSpanT,
         coordinates(nga.sp1), 
         col="blue", 
         cex.lab=0.7, 
         cex.circles=0.005, 
         add=TRUE)
```

### 5.2.4 Compute Spatially Constrained Cluster

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***skater( )*** - spdep -]{style="color:#d46e15"} to compute the spatially constrained cluster.

```{r}
clust5 <- spdep::skater(edges = nga_minSpanT[,1:2],
                        data = cluster_varsTrim1,
                        method = "euclidean",
                        ncuts = 4)
str(clust5)
```

#### 5.2.4.1 tabulate cluster assignment

```{r}
ccs5 <- clust5$groups
table(ccs5)
```

#### 5.2.4.2 plot the pruned tree

```{r}
plot(nga.sp1, border=gray(.5))
plot(clust5, 
     coordinates(nga.sp1), 
     cex.lab=.7,
     groups.colors=c("red","green","blue", "brown", "pink"),
     cex.circles=0.005, 
     add=TRUE)
```

### 5.2.5 Visualise SKATER Clusters in Choropleth Map

```{r}
groups_mat <- as.matrix(clust5$groups)

nga_spClust.sf <- cbind(nga_clust.sf1, as.factor(groups_mat)) %>%
  rename(`sp_cluster`=`as.factor.groups_mat.`)
```

To compare the output of hierarchical clustering and spatially constrained hierarchical clustering :

```{r}
hieClust_map <- qtm(nga_clust.sf1,
                  "cluster") + 
  tm_borders(alpha = 0.5) 

ngaClust_map <- qtm(nga_spClust.sf,
                   "sp_cluster") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(hieClust_map, ngaClust_map,
             asp=NA, ncol=2)
```

## 5.3 Spatially Constrained Clustering :: ClustGeo Method

### 5.3.1 Perform Ward-like Hierarchical Clustering

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***hclustgeo( )*** - ClustGeo -]{style="color:#d46e15"} to perform a typical Ward-like hierarchical clustering.

```{r}
proxmat_ngc <- dist(cluster_varsTrim1, method = 'euclidean')
```

```{r}
nonGeo_clust <- hclustgeo(proxmat_ngc)
plot(nonGeo_clust, cex = 0.5)
rect.hclust(nonGeo_clust, 
            k = 5, 
            border = 2:5)
```

#### 5.3.1.1 visualise the formed clusters

```{r}
groups_ngc <- as.factor(cutree(nonGeo_clust, k=5))
```

```{r}
nga_ngeo_clust.sf <- cbind(wp_ngaTrans1, as.matrix(groups_ngc)) %>%
  rename(`cluster` = `as.matrix.groups_ngc.`)
```

```{r}
qtm(nga_ngeo_clust.sf, "cluster")
```

### 5.3.2 Perform Spatially Constrained Hierarchical Clustering

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***st_distance( )*** - sf -]{style="color:#d46e15"} to derive the spatial distance matrix before perform spatially constrained hierarchical clustering.

[***as.dist( )*** - stats -]{style="color:#d46e15"} to convert the data frame into matrix.

```{r}
dist <- st_distance(wp_ngaTrans1, wp_ngaTrans1)
dist_mat <- as.dist(dist)
```

#### 5.3.2.1 determine alpha value

[***choicealpha( )*** - psych -]{style="color:#d46e15"} to determine a suitable value for the mixing parameter alpha.

```{r}
cr <- choicealpha(
  proxmat_ngc, 
  dist_mat, 
  range.alpha = seq(0, 1, 0.1), 
  K=5, 
  graph = TRUE)
```

Remarks :

With reference to the plot above, alpha = 0.4 to be used to perform spatially constrained hierarchical clustering.

#### 5.3.2.2 compute spatially constrained hierarchical clustering

```{r}
clustG <- hclustgeo(proxmat_ngc, 
                    dist_mat, 
                    alpha = 0.4)
```

#### 5.3.2.3 derive cluster object

```{r}
groups_cg <- as.factor(cutree(clustG, k=5))
```

#### 5.3.2.4 combine *group_cg* with *wp_ngaTrans1*

```{r}
wp_nga1_GClust <- cbind(wp_ngaTrans1, as.matrix(groups_cg)) %>%
  rename(`cluster` = `as.matrix.groups_cg.`)
```

#### 5.3.2.5 plot delineated spatially constrained cluster

```{r}
qtm(wp_nga1_GClust, "cluster")
```

<br>

## 5.4 Visual Interpretation of Clusters

### 5.4.1 Visualise Individual Clustering Variable

5.4.1.1 plot boxplot

```{r}
ggplot(data = nga_ngeo_clust.sf,
       aes(x = cluster, y = pct_functional)) +
  geom_boxplot()
```

Remarks :

The boxplot reveals Cluster 5 displays the highest mean of functional water points. This is followed by Cluster 1, 3, 2, and 4.

### 5.4.2 Visualise Multivariate

[Usage of the code chunk below :]{style="color:#5e5c5c"}

[***ggparcoord( )*** - GGally -]{style="color:#d46e15"} to reveal clustering variables by cluster.

```{r}
nga_ngeo_clust.sf1 <- nga_ngeo_clust.sf %>%
  select("shapeName", 
         "pct_functional", 
         "pct_nonFunctional", 
         "pct_unknown", 
         "pct_handPump", 
         "pct_tapStand", 
         "pct_uc300", 
         "pct_uc1000", 
         "pct_uc250", 
         "pct_urban0",
         "cluster")
         
head(nga_ngeo_clust.sf1,3)
```

```{r}
ggparcoord(data = nga_ngeo_clust.sf,
           columns = c(2:19),
           scale = "globalminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of Variables by Cluster") +
  facet_grid(~ cluster, scales = "fixed") + 
  theme(axis.text.x = element_text(angle = 30))
```

The parallel coordinate plot above reveals that households in Cluster 4 townships tend to own the highest number of TV and mobile-phone. On the other hand, households in Cluster 5 tends to own the lowest of all the five ICT.

Note that the `scale` argument of `ggparcoor()` provide several methods to scale the clustering variables. They are:

-   std: univariately, subtract mean and divide by standard deviation.

-   robust: univariately, subtract median and divide by median absolute deviation.

-   uniminmax: univariately, scale so the minimum of the variable is zero, and the maximum is one.

-   globalminmax: no scaling is done; the range of the graphs is defined by the global minimum and the global maximum.

-   center: use uniminmax to standardize vertical height, then center each variable at a value specified by the scaleSummary param.

-   centerObs: use uniminmax to standardize vertical height, then center each variable at the value of the observation specified by the centerObsID param

### 5.4.3 Compute Summary Statistics

```{r}
nga_ngeo_clust.sf %>% 
  st_set_geometry(NULL) %>%
  group_by(cluster) %>%
  summarise(mean_pct_functional = mean(pct_functional),
            mean_pct_nonFunctional = mean(pct_nonFunctional),
            mean_pct_unknown = mean(pct_unknown),
            mean_pct_handPump = mean(pct_handPump), 
            mean_pct_tapStand = mean(pct_tapStand), 
            mean_pct_uc300 = mean(pct_uc300), 
            mean_pct_uc1000 = mean(pct_uc1000), 
            mean_pct_uc250 = mean(pct_uc250), 
            mean_pct_urban0 = mean(pct_urban0))
         
```
