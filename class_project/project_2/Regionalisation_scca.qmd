---
title: "Regionalisation with Spatially Constrained Cluster Analysis"
editor: visual
date: 5 Dec 2022
reference-location: margin
citation-location: margin
code-copy: true
website: 
    google-analytics: "G-VVFCV6MNHG"
format:
  html:
    code-overflow: wrap
    code-fold: true
    code-summary: "Show the code"
    css: styles.css
---

case study : ***Regionalisation by Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods.***

# 1. OVERVIEW

Regionalisation with Spatially Constrained clustering analysis requires similar observations to be grouped according to their statistical attributes and spatial location.

## 1.1 Objectives

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**Regionalise Nigeria based on water points' attribute**]{style="color:#93c54b"}

-   Total number of water points by status, i.e. functional, non-functional, and unknown;

-   Percentage of water points by :

    -   status (functional, non-functional, and unknown);

    -   deployed water technology (hand pump, mechanical pump, stand tap, etc.) ;

    -   usage capacity (1000, 300, 250, 50);

    -   rural or urban.
:::

## 1.2 Study Area Introduction

::: {.callout-tip .column-page collapse="true" appearance="simple" icon="false"}
## [**Water points in Federal Republic of Nigeria**]{style="color:#93c54b"}

Alpha-3 Code : **NGA**

Population : **225 million** (1st in Africa, 6th globally)

Local Government Areas (LGA) : **774**

Water Point Observations : **95,008**

Environmental Aspects :

-   **Geography** :

    -   Southwest - "rugged" highland.

    -   Southeast - hills and mountains, which form the Mambilla Plateau, the highest plateau in Nigeria.

-   **Hydrology** :

    -   Two (2) main catchment areas - Chad Basin & Niger catchment area.

    -   Surface area of lake Chad is shrinking recent decades due to irrigation activities.[^1]

    -   Untreated wastes dump in places resulted in waterways and groundwater pollution.[^2]

-   **Vegetation Coverage** :

    -   Lost nearly 80% of primary forest by 2012.[^3]

    -   States with dense forests concentrated : Bayelsa, Cross River, Edo, Ekiti, Ondo, Osun, Rivers, and Taraba.
:::

[^1]: Wikipedia. *Nigeria.* https://en.wikipedia.org/wiki/Nigeria

[^2]: Ogbonna, D.N., Ekweozor, I.K.E., Igwe, F.U. (2002). "Waste Management: A Tool for Environmental Protection in Nigeria". *Ambio: A Journal of the Human Environment*. **31** (1): 55--57. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1639/0044-7447(2002)031\[0055:wmatfe\]2.0.co;2](https://doi.org/10.1639%2F0044-7447%282002%29031%5B0055%3Awmatfe%5D2.0.co%3B2).

[^3]: https://rainforests.mongabay.com/20nigeria.htm

## 1.3 Scope of Works

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
### [**Specific tasks required for this study :**]{style="color:#93c54b"}

-   import the shapefile into R with the appropriate *sf* method, and save it in a simple feature data frame format;

::: callout-note
Three (3) Projected Coordinate Systems of Nigeria, EPSG : [26391](https://epsg.io/26391), 26392, and 26303.
:::

-   derive the proportion of functional and non-functional water points at LGA level (i.e. ADM2) by appropriate tidyr and dplyr methods;

-   combine geospatial and aspatial data frames into a simple feature data frame.

-   delineate water points measures functional regions by using :

    -   conventional hierarchical clustering.

    -   spatially constrained clustering algorithms.

-   plot two (2) main types of maps below :

    **Thematic Mapping**

    Show the derived water-point measures by appropriate statistical graphics and choropleth mapping technique.

    **Analytical Mapping**

    Plot delineated functional regions using non-spatially constrained and spatially constrained clustering algorithms.
:::

# 2. R PACKAGE REQUIRED

The following are the packages required for this exercise :

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**Load one or more packages**]{style="color:#93c54b"}

-   pacman package :

    -   [*p_load( )*](https://www.rdocumentation.org/packages/pacman/versions/0.5.1/topics/p_load) - [2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#load-r-packages-into-r-environment)
:::

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**Import and process Geospatial data**]{style="color:#93c54b"}

-   sf package :

    -   [*st_as_sfc( )*](https://www.rdocumentation.org/packages/sf/versions/1.0-9/topics/st_as_sfc) - [3.2.5.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#derive-new-field-geometry)

    -   [*st_sf( )*](https://www.rdocumentation.org/packages/sf/versions/0.1-1/topics/ST_sf) - [3.2.5.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#convert-to-sf-data-frame)

    -   [*st_crs( )*](https://www.rdocumentation.org/packages/sf/versions/1.0-9/topics/st_crs)- [3.2.5.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#convert-to-sf-data-frame)

    -   [*st_geometry( )*](https://www.rdocumentation.org/packages/sf/versions/1.0-9/topics/st_geometry)- [3.2.5.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#retrieve-geometry-summary-wp_sf), [3.4.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#inspect-joined-file-wp_joined)

    -   [*st_read( )*](https://www.rdocumentation.org/packages/sf/versions/0.2-2/topics/st_read) - [3.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-boundary-data-of-nigeria-lga)

    -   [*st_join( )*](https://www.rdocumentation.org/packages/sf/versions/0.5-5/topics/st_join) - [3.4.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#join-objects-wp_sf-and-bdy_nga)

    -   *st_set_crs( )* - [3.4.5.20](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#transform-to-projected-coordinate-system)

    -   [*st_set_geometry( )*](https://r-spatial.github.io/sf/reference/st_geometry.html) *-* [4.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#create-data-table-for-correlation-matrix-analysis)

-   stars package :

    -   [*st_intersects( )*](https://www.rdocumentation.org/packages/stars/versions/0.5-0/topics/st_intersects.stars)- [3.4.5.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#add-attribute-to-new-data-table)
:::

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**Import and process Aspatial data**]{style="color:#93c54b"}

-   tidyverse :
    -   readr package :

        -   [*read_csv( )*](https://readr.tidyverse.org/reference/read_delim.html) - [3.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-coordinate-related-variable), [3.2.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-status-and-condition-related-variable), [3.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-lga-and-measure-related-variable), 3.2.2.1

        -   [*problems( )*](https://www.rdocumentation.org/packages/readr/versions/1.3.1/topics/problems) - [3.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-coordinate-related-variable), [3.2.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-status-and-condition-related-variable), [3.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-lga-and-measure-related-variable), [3.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-boundary-data-of-nigeria-lga)

        -   [*write_rds( )*](https://readr.tidyverse.org/reference/read_rds.html) *-* [3.2.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_coord), [3.2.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_cond), [3.2.3.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_adm), [3.4.2.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_joined), [3.4.5.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wpt_functional)

        -   [*read_rds( )*](https://readr.tidyverse.org/reference/read_rds.html)- [3.2.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_coord), [3.2.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_cond), [3.2.3.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_adm), [3.4.2.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wp_joined), [3.4.4.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#read-rds-file-wp_joined1), [3.4.5.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#save-and-read-rds-file-wpt_functional)

    -   dplyr :

        -   [*rename( )*](https://dplyr.tidyverse.org/reference/rename.html) - [3.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-coordinate-related-variable), [3.2.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-status-and-condition-related-variable), [3.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-lga-and-measure-related-variable)

        -   [*filter( )*](https://dplyr.tidyverse.org/reference/filter.html) - [3.3.1.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#list-the-duplicated-value-shapename), [3.4.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#validate-edited-value-shapename), [3.4.5.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#extract-functional-water-point)

        -   [*left_join( )*](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/join) - [3.2.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#create-master-file),

        -   [*select( )*](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/select) - [3.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#import-boundary-data-of-nigeria-lga), [3.3.1.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#list-the-duplicated-value-shapename), [3.4.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#validate-edited-value-shapename)

        -   [*add_count( )*](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/tally) - [3.3.1.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#list-the-duplicated-value-shapename), [3.4.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#validate-edited-value-shapename)

        -   [*mutate( )*](https://www.rdocumentation.org/packages/dplyr/versions/0.5.0/topics/mutate) - [3.4.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#replace-na-with-unknown), [3.4.4.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#combine-value-status_clean)

    -   tidyr :

        -   [*replace_na( )*](https://www.rdocumentation.org/packages/tidyr/versions/0.8.3/topics/replace_na) - [3.4.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#replace-na-with-unknown), [3.4.5.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#replace-nan-with-0)
:::

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**Plot map for visualisation**]{style="color:#93c54b"}

-   tmap :

    -   [*tmap_mode( )*](https://www.rdocumentation.org/packages/tmap/versions/3.3-3/topics/tmap_mode) - [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

    -   [*tm_shape( )*](https://www.rdocumentation.org/packages/tmap/versions/3.3-3/topics/tm_shape) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

    -   [*tm_polygons( )*](https://rdrr.io/cran/tmap/man/tm_polygons.html) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

    -   [tm_view( )](https://rdrr.io/cran/tmap/man/tm_view.html) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

    -   [*tm_fill( )*](https://search.r-project.org/CRAN/refmans/tmap/html/tm_polygons.html) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

    -   [*tm_borders( )*](https://www.rdocumentation.org/packages/tmap/versions/0.7/topics/tm_borders) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

    -   [*tmap_style( )*](https://rdrr.io/cran/tmap/man/tmap_style.html) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

    -   [*tm_layout( )*](https://www.rdocumentation.org/packages/tmap/versions/3.3-3/topics/tm_layout) *-* [3.3.1.4](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#verify-findings-in-section-3.3.1.3)

    -   *qtm( )* - [3.4.5.12](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#visualise-distribution-status_clean)

    -   *tmap_arrange( )* - [3.4.5.12](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#visualise-distribution-status_clean)
:::

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**Plot graph and chart**]{style="color:#93c54b"}

-   ggplot2 package :

    -   [*ggplot( )*](https://www.rdocumentation.org/packages/ggplot2/versions/3.4.0/topics/ggplot) - [3.4.5.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#exploratory-data-analysis-eda-wpt_functional)

    -   [*geom_bar( )*](https://www.rdocumentation.org/packages/ggplot2/versions/1.0.1/topics/geom_bar) - [3.4.5.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#exploratory-data-analysis-eda-wpt_functional)

    -   [*geom_text( )*](https://www.rdocumentation.org/packages/ggplot2/versions/0.9.1/topics/geom_text) - [3.4.5.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#exploratory-data-analysis-eda-wpt_functional)

    -   [*scale_x\_discrete( )*](https://ggplot2.tidyverse.org/reference/scale_discrete.html) - [3.4.5.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#exploratory-data-analysis-eda-wpt_functional)

    -   [*geom_boxplot( )*](https://www.rdocumentation.org/packages/ggplot2/versions/1.0.1/topics/geom_boxplot)- [3.5.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#plot-boxplot-pct_functional)

    -   [*geom_histogram( )*](https://www.rdocumentation.org/packages/ggplot2/versions/0.9.1/topics/geom_histogram) - [3.5.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#plot-histogram-for-status_clean)

-   egg package :

    -   [*ggarrange( )*](https://www.rdocumentation.org/packages/egg/versions/0.4.5/topics/ggarrange) - [3.5.2.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#plot-histogram-for-status_clean)
:::

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**Visualise correlation matrix**]{style="color:#93c54b"}

-   corrplot package :

    -   [*corrplot.mixed( )*](https://www.rdocumentation.org/packages/corrplot/versions/0.92/topics/corrplot.mixed) - [4.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#visualise-correlation-matrix-1)
:::

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**Get descriptive stats**]{style="color:#93c54b"}

-   questionr :

    -   [*freq.na( )*](https://www.rdocumentation.org/packages/questionr/versions/0.7.7/topics/freq.na)- [3.3.1.1](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#check-for-missing-data)
    -   [*freq( )*](https://www.rdocumentation.org/packages/questionr/versions/0.7.7/topics/freq) *-* [3.3.1.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#check-for-duplication-shapename), [3.4.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#determine-reference-point-shapename-or-clean_adm2)

-   factoextra :

    -   [*fviz_nbclust( )*](https://www.rdocumentation.org/packages/factoextra/versions/1.0.7/topics/fviz_nbclust) -

-   skimr package :

    -   [*skim( )*](https://www.rdocumentation.org/packages/skimr/versions/2.1.4/topics/skim) -

-   stats :

    -   [*dist( )*](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/dist) - 5.1.2

    -   [*as.dist( )*](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/dist) -
:::

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## [**Miscellaneous generic functions**]{style="color:#93c54b"}

-   janitor package :

    -   [*get_dupes( )*](https://www.rdocumentation.org/packages/janitor/versions/2.1.0/topics/get_dupes) *-* [3.4.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#assess-uniqueness-of-each-water-point)

-   [plyr package](https://www.rdocumentation.org/packages/plyr/versions/1.8.8) :

    -   *count( )* - [3.4.5.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#reveal-value-usage_capacity-by-status_clean)

-   [base package](https://www.rdocumentation.org/packages/base/versions/3.6.2) :

    -   [*summary( )*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/summary) - [3.2.1.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#review-data-frame-wp_coord), [3.2.2.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#review-data-frame-wp_cond), [3.2.3.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#review-data-frame-wp_adm), [3.4.2.3](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#reveal-value-crucialness_score), [3.4.5.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#reveal-value-crucialness_score-1)

    -   [*duplicated( )*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/duplicated) - [3.3.1.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#check-for-duplication-shapename)

    -   [*length( )*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/length)- [3.4.5.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#inspect-variable-and-value)

    -   [*sum( )*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/sum) *-* [3.4.5.2](https://geospatial-analysis-jeph0stan.netlify.app/class_project/project_2/regionalisation_scca#determine-the-total-population-within-1-km-by-crucialness_score)
:::

## 2.1 Load R Packages

::: {.callout-warning appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***p_load( )*** - pacman -]{style="color:#d46e15"} to load packages. This function will attempt to install the package from CRAN or pacman repository list if its found not installed.

```{r}
pacman::p_load(sf, tidyverse, questionr, janitor, psych, ggplot2, gcookbook, tmap, ggpubr, egg, corrplot, gtsummary, regclass, caret, heatmaply, ggdendro, cluster, factoextra, spdep, ClustGeo, GGally, skimr, stringr, funModeling, knitr, caTools, viridis)
```
:::

# 3. GEOSPATIAL DATA

## 3.1 Acquire Data Source

-   **Aspatial Data**

    1.  Download the Nigeria data set in shapefile format via [Access WPdx+ Global Data Repository](https://data.waterpointdata.org/dataset/Water-Point-Data-Exchange-Plus-WPDx-/eqje-vguj/data) from [WPdx Global Data Repositories](https://www.waterpointdata.org/access-data/).
    2.  Rename the title of the data set to "***geo_export***".

::: callout-note
The file size of the downloaded data is about 422 MB due to water points data from multiple countries.

-   Such file size may require extra effort and time to manage the code chunks and files in the R environment before pushing them to GitHub.

Hence, to avoid any error in pushing files larger than 100 MB to Git, filtered Nigeria water points and removed unnecessary variables before uploading into the R environment.

Therewith, the CSV file size should be lesser than 100 MB.
:::

-   **Geospatial Data**

    1.  Download the Nigeria geoBoundaries data set at ADM2 level[^4] from [geoBoundaries.org](https://www.geoboundaries.org/index.html#getdata) or the [Humanitarian Data Exchange portal](https://data.humdata.org/).
    2.  Rename the title of the data set to "***nga_admbnda_adm2_osgof_20190417***"

[^4]: Runfola, D. et al. (2020) geoBoundaries: A global database of political administrative boundaries. PLoS ONE 15(4): e0231866. https://doi.org/10.1371/journal.pone.0231866

## 3.2 Import Attribute Data

Four (4) data frames to be created for different context, i.e.

-   *wp_coord* = coordinated related variables.

-   *wp_cond* = status and conditions related variables.

-   *wp_adm* = administrative and measurements related variables.

-   *wp* = master file that combine all three (3) data frames above.

### 3.2.1 Import Coordinate-related Variable

::: {.callout-warning appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***read_csv( )*** - readr -]{style="color:#d46e15"} to import and save the comma separated value (CSV) file as a data frame, with title "*wp_coord*".

-   [**c*ol_select( )*** - readr -]{style="color:#d46e15"} to include only the selected variables into *wp_cood* data frame.

[***rename( )*** - dplyr -]{style="color:#d46e15"} to remove "\#" from the variables.

[***problems( )*** - readr -]{style="color:#d46e15"} to reveal any parsing errors when importing the CSV file.
:::

```{r}
#| eval: false
wp_coord <- read_csv("data/aspatial/WPdx_NGAv1.2.1.csv",
                       col_select = c(`row_id`,
                                      `#lat_deg`,
                                      `#lon_deg`,
                                      `New Georeferenced Column`,
                                      `lat_lon_deg`)) %>%
  rename(lat_deg = "#lat_deg", 
         lon_deg = "#lon_deg")

problems(wp_coord)
```

Remarks :

[Upload and create new data frames according to the context of the variables. Therewith, these data frames can be used as and when the requirements fit the context thereof.]{style="color:#d69c3c"}
:::

#### 3.2.1.1 save and read RDS file :: *wp_coord*

::: {.callout-warning appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***write_rds( )*** - readr -]{style="color:#d46e15"} to save *wp_coord* data table into an RDS format.

**note : reduce the file size with this function -\> compress = "xz".**

[***read_rds( )*** - readr -]{style="color:#d46e15"} to read *wp_coord* RDS file into *wp_coord*.
:::

```{r}
#| eval: false
write_rds(wp_coord,"data/geodata/wp_coord.rds",compress = "xz")
```

```{r}
#| code-fold: false
wp_coord <- read_rds("data/geodata/wp_coord.rds")
```
:::

#### 3.2.1.2 review data frame :: *wp_coord*

::: {.callout-warning .column-page-right appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***skim( )*** - skimr -]{style="color:#d46e15"} to get a broad overview of *wp_coord* data frame.
:::

```{r}
skim(wp_coord)
```
:::

### 3.2.2 Import Status and Condition-related Variable

::: {.callout-warning appearance="simple" icon="false"}
```{r}
#| eval: false
wp_cond <- read_csv("data/aspatial/WPdx_NGAv1.2.1.csv", 
                     col_select = c(`row_id`,
                                    `#water_source`,
                                    `#water_source_clean`,
                                    `#water_source_category`,
                                    `#water_tech_clean`,
                                    `#water_tech_category`,
                                    `#status_clean`,
                                    `#status`)) %>%
  rename(water_source = `#water_source`,
         water_source_clean = `#water_source_clean`, 
         water_source_category = `#water_source_category`, 
         water_tech_clean = `#water_tech_clean`, 
         water_tech_category = `#water_tech_category`,
         status_clean = `#status_clean`,
         status = `#status`)

problems(wp_cond)
```
:::

#### 3.2.2.1 save and read RDS file :: *wp_cond*

::: {.callout-warning appearance="simple" icon="false"}
```{r}
#| eval: false
write_rds(wp_cond,"data/geodata/wp_cond.rds",compress = "xz")
```

```{r}
#| code-fold: false
wp_cond <- read_rds("data/geodata/wp_cond.rds")
```
:::

#### 3.2.2.2 review data frame :: *wp_cond*

::: {.callout-warning .column-page-right appearance="simple" icon="false"}
```{r}
skim(wp_cond)
```
:::

### 3.2.3 Import Admistrative and Measure-related Variable

::: {.callout-warning appearance="simple" icon="false"}
```{r}
#| eval: false
wp_adm <- read_csv("data/aspatial/WPdx_NGAv1.2.1.csv", 
                    col_select = c(`row_id`,
                                   `#clean_adm1`,
                                   `#clean_adm2`,
                                   `water_point_population`,
                                   `local_population_1km`,
                                   `crucialness_score`,
                                   `pressure_score`,
                                   `usage_capacity`,
                                   `staleness_score`,
                                   `rehab_priority`,
                                   `is_urban`)) %>%
  rename(clean_adm1 = `#clean_adm1`,
         clean_adm2 = `#clean_adm2`)

problems(wp_adm)
```
:::

#### 3.2.3.1 save and read RDS file :: *wp_adm*

::: {.callout-warning appearance="simple" icon="false"}
```{r}
#| eval: false
write_rds(wp_adm,"data/geodata/wp_adm.rds",compress = "xz")
```

```{r}
#| code-fold: false
wp_adm <- read_rds("data/geodata/wp_adm.rds")
```
:::

#### 3.2.3.2 review data frame :: *wp_adm*

::: {.callout-warning .column-page-right appearance="simple" icon="false"}
```{r}
skim(wp_adm)
```
:::

### 3.2.4 Create Master File

::: {.callout-warning appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***left_join( )*** - dplyr -]{style="color:#d46e15"} to combine *wp_coord, wp_cond* and *wp_adm.*
:::

```{r}
wp <- left_join(
  (left_join
   (wp_coord,wp_cond,
     by = c("row_id")
     )),
  wp_adm, 
  by = c("row_id"))
```
:::

### 3.2.5 Convert Well Known Text (WKT) Data to SF Data Frame

-   The "New Georeferenced Column" in *wp_rds* contains spatial data in a WKT format.

-   Two (2) steps to convert the WKT data format into an sf data frame.

#### 3.2.5.1 derive new field :: "geometry"

::: {.callout-warning appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***st_as_sfc( )*** - sf -]{style="color:#d46e15"} to convert foreign geometry object \`New Georeferenced Column\` to an sfc object
:::

```{r}
wp$geometry = st_as_sfc(wp$`New Georeferenced Column`)
```
:::

#### 3.2.5.2 convert to SF Data Frame

::: {.callout-warning appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***st_sf( )*** - sf -]{style="color:#d46e15"} to convert the tibble data frame into sf data frame with crs first set to WGS 84 (EPSG : 4326).

[***st_crs( )*** - sf -]{style="color:#d46e15"} to retrieve coordinate reference system from the object.
:::

```{r}
wp_sf<- st_sf(wp, crs = 4326)
st_crs(wp_sf)
```
:::

## 3.3 Import Boundary Data

::: {.callout-warning appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***st_read( )*** - sf -]{style="color:#d46e15"} to read simple features.

[***select( )*** - dplyr -]{style="color:#d46e15"} to select "shapeName" variable.
:::

```{r}
#| eval: false
bdy_nga <- st_read(dsn = "data/geospatial",
               layer = "geoBoundaries-NGA-ADM2",
               crs = 4326) %>%
  select(shapeName)

problems(bdy_nga)
```
:::

#### 3.3.1 save and read RDS file :: *wp_adm*

::: {.callout-warning appearance="simple" icon="false"}
```{r}
#| eval: false
write_rds(bdy_nga,"data/geodata/bdy_nga.rds",compress = "xz")
```

```{r}
#| code-fold: false
bdy_nga <- read_rds("data/geodata/bdy_nga.rds")
```
:::

### 3.3.2 Review Imported File

#### 3.3.2.1 check for missing and duplicated data

::: {.callout-warning .column-page-right appearance="simple" icon="false"}
```{r}
skim(bdy_nga)
```

Remarks :

-   There is no missing data.

-   There 774 unique "geometry" but only 768 unique "shapeName"

    -   That's mean there are 6 values of "shapeName" duplicated among the identified unique shapeNames.
:::

#### 3.3.2.2 list the unique "shapeName" associated with duplication

::: {.callout-warning appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***add_count( )*** - dplyr -]{style="color:#d46e15"} to count observations by group

[***filter( )*** - dplyr -]{style="color:#d46e15"} to retain shapeName that has count not equal to 1.
:::

```{r}
dupl_shapeName <- bdy_nga %>%
  add_count(bdy_nga$shapeName) %>%
  filter(n!=1) %>%
  select(-n)

freq(dupl_shapeName$shapeName)
```
:::

#### 3.3.2.3 verify findings in section 3.3.1.2

::: {.callout-warning .column-page-right appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***tmap_mode( )*** - tmap -]{style="color:#d46e15"} to set tmap mode to static plotting or interactive.

[***tm_shape( )*** - tmap -]{style="color:#d46e15"} to specify the shape object.

[***tm_polygons( )*** - tmap -]{style="color:#d46e15"} to fill the polygons and draw the polygon borders.

[***tm_view( )*** - tmap -]{style="color:#d46e15"} to set the options for the interactive tmap viewer.

[***tm_fill( )*** - tmap -]{style="color:#d46e15"} to specify either which colour to be used or which data variable mapped to the colour palette.

[***tm_borders( )*** - tmap -]{style="color:#d46e15"} to draw the polygon borders.

[***tmap_style( )*** - tmap -]{style="color:#d46e15"} to set the tmap style.

[***tm_layout( )*** - tmap -]{style="color:#d46e15"} to set the layout of cartographic map.
:::

```{r}
tmap_mode("view")

tm_shape(bdy_nga)+
  tm_polygons()+
  tm_view(set.zoom.limits = c(6,8))+

tm_shape(dupl_shapeName)+
  tm_fill("shapeName",
          n = 6,
          style = "jenks")+
  tm_borders(alpha = 0.5)+
  tmap_style("albatross")+
  tm_layout(main.title = "Distribution of Duplicated ShapeName",
            main.title.size = 1.3,
            main.title.position = "center")

tmap_mode("plot")
```

Remarks :

The plot above indicates those duplicated water points are not within the same location.
:::

#### 3.3.2.4 acquire State info for duplicated value

::: {.callout-warning appearance="simple" icon="false"}
The State info to be combined with the duplicated "shapeName". This will make all the shapeName unique.

```{r}
dupl_shapeName %>%
  mutate(st_centroid(
    dupl_shapeName$geometry, of_largest_polygon = FALSE))

glimpse(dupl_shapeName)
```
:::

| lga      | row_id | headquarter | state    | iso3166code | dupl_shapeName_coord | lga_office_coord                                                                                                                                                                                                                                                                                                          |
|----------|--------|-------------|----------|-------------|----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Bassa    | 94     | Oguma       | Kogi     | NG.KO.BA    | 7.791971, 7.031827   | [7.80932, 6.74853](https://goo.gl/maps/WDitgPiphRDGX52d9)                                                                                                                                                                                                                                                                 |
| Bassa    | 95     | Bassa       | Plateau  | NG.PL.BA    | 10.08015, 8.782946   | [10.11143, 8.71559](https://goo.gl/maps/eNj4Aqan83aiM7AK8)                                                                                                                                                                                                                                                                |
| Ifelodun | 304    | Share       | Kwara    | NG.KW.IF    | 8.544311, 5.052235   | [8.5 5.0](https://latitude.to/map/ng/nigeria/regions/kwara-state/)                                                                                                                                                                                                                                                        |
| Ifelodun | 305    | Ikirun      | Osun     | NG.OS.ID    | 7.920948, 4.636735   | [7.5 4.5](https://latitude.to/map/ng/nigeria/regions/osun-state/)                                                                                                                                                                                                                                                         |
| Irepodun | 355    | Omu Aran    | Kwara    | NG.KW.IR    | 8.169349, 4.926215   | [8.5 5.0](https://latitude.to/map/ng/nigeria/regions/kwara-state/)                                                                                                                                                                                                                                                        |
| Irepodun | 356    | Ilobu       | Osun     | NG.OS.IP    | 7.84861, 4.498797    | [7.5 4.5](https://latitude.to/map/ng/nigeria/regions/osun-state/)                                                                                                                                                                                                                                                         |
| Nasarawa | 519    | Bompai      | Kano     | NG.KN.NA    | 12.00446, 8.578262   | [11.5, 8.5](https://latitude.to/map/ng/nigeria/regions/kano-state/)                                                                                                                                                                                                                                                       |
| Nasarawa | 520    | Nasarawa    | Nasarawa | NG.NA.NA    | 8.304034, 7.760272   | [8.53477, 7.70153](https://goo.gl/maps/gZptpjpGGAPkPhFp7)                                                                                                                                                                                                                                                                 |
| Obi      | 546    | Obarike-Ito | Benue    | NG.BE.OB    | 7.022495, 8.281026   | [7.01129, 8.33118](https://www.google.com/maps/place/Obi+L+G+A+Office+Benue+State+Nigeria/@7.0173612,8.317536,15z/data=!4m5!3m4!1s0x105b02a2fcb55b01:0x534d97153bbf03f6!8m2!3d7.0101782!4d8.3282674)                                                                                                                      |
| Obi      | 547    | Obi         | Nasarawa | NG.NA.OB    | 8.35534, 8.734777    | [8.37944, 8.78561](https://www.google.com/maps/place/Local+Govt+Secretariat/@8.3740903,8.7748577,14.55z/data=!4m5!3m4!1s0x1050e131ff5c6639:0x76010b5a66e763d7!8m2!3d8.3781745!4d8.782189)                                                                                                                                 |
| Surelere | 693    | Surelere    | Lagos    | NG.LA.SU    | 6.493217, 3.346919   | [6.50048, 3.35488](https://www.google.com/maps/place/Local+Government+Office/@6.4997824,3.3523702,17z/data=!3m1!4b1!4m5!3m4!1s0x103b8c1437be057d:0xc427d7c19d4332af!8m2!3d6.4997848!4d3.3545626)                                                                                                                          |
| Surelere | 694    | Iresa-Adu   | Oyo      | NG.OY.SU    | 8.088897, 4.393574   | [8.08459, 4.38538](https://www.google.com/maps/place/Iresa+Adu+Local+government+house/@8.0860984,4.3846214,15.95z/data=!4m13!1m7!3m6!1s0x103775694baada77:0xcb78cc728922fde9!2s210104,+Aba+Ladunni,+Oyo,+Nigeria!3b1!8m2!3d8.0885998!4d4.3928622!3m4!1s0x103775d913035017:0xe95c9c72c52ac566!8m2!3d8.0844129!4d4.3838421) |

## 3.4 Data Wrangling

### 3.4.1 Edit Duplicated Value :: "shapeName"

::: {.callout-warning appearance="simple" icon="false"}
Two (2) Main Steps involved :

1.  Combine "shapeName" with the State name to make each of them unique.
2.  Replace the "shapeName" value according to each row index.[^5]

```{r}
bdy_nga$shapeName[c(94,95,304,305,355,356,519,520,546,547,693,694)] <- 
  c("Bassa Kogi",
    "Bassa Plateau",
    "Ifelodun Kwara",
    "Ifelodun Osun",
    "Irepodun Kwara",
    "Irepodun Osun",
    "Nasarawa Kano",
    "Nasarawa Nasarawa",
    "Obi Nasarawa",
    "Obi Benue",
    "Surulere Lagos",
    "Surulere Oyo")

bdy_nga$shapeName[c(94,95,304,305,355,356,519,520,546,547,693,694)]
```

#### 3.4.1.1 validate edited value :: "shapeName"

```{r}
dupl_shapeName_val <- bdy_nga %>%
  add_count(bdy_nga$shapeName) %>%
  filter(n!=1) %>%
  select(-n)

dupl_shapeName_val
```
:::

[^5]: Ong Z.R.J. (2022). Geospatial Analytics for Social Good - Understanding Nigeria Water functional and non-functional water point rate. https://jordan-isss624-geospatial.netlify.app/posts/geo/geospatial_exercise/#checking-of-duplicated-area-name

### 3.4.2 Perform Point-in-Polygon Overlay

::: {.callout-warning appearance="simple" icon="false"}
Combine both attribute and boundary of the water points into a simple feature object.

#### 3.4.2.1 join objects :: *wp_sf*, *bdy_nga*

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***st_join( )*** - sf -]{style="color:#d46e15"} to join *sf*-class objects based on geometry, namely, *wp_sf* and *bdy_nga*.
:::

```{r}
#| eval: false
wp_joined <- st_join(x = wp_sf,
                     y = bdy_nga,
                     join = st_intersects,
                     left = TRUE)
```

#### \-- save and read RDS File :: *wp_joined*

```{r}
#| eval: false
write_rds(wp_joined,"data/geodata/wp_joined.rds",compress = "xz")
```

```{r}
#| code-fold: false
wp_joined <- read_rds("data/geodata/wp_joined.rds")
```

#### 3.4.2.2 inspect joined file :: *wp_joined*

#### \-- assess uniqueness of Water Point

```{r}
#| code-fold: false
wp_joined %>% janitor::get_dupes(shapeName,lat_lon_deg)
```

Remarks :

Each water point observation is unique as there are no duplicate combination of "shapeName" together with "lat_lon_deg".

#### \-- determine reference point :: "shapeName" or "clean_adm2"

```{r}
wp_reference <- (wp_joined$shapeName == wp_joined$clean_adm2)

summary(wp_reference)
```

Remarks :

-   There are 29,713 "FALSE", which is more than 30% of LGA names mismatched between "shapeName" and "clean_adm2".

    -   [Since the geoBoundaries data is collected from government-published and reliable internet sources.]{style="color:#d69c3c"}[^6]

        -   [Hence, the "shapeName" variable to be used throughout this study.]{style="color:#d69c3c"}

-   The 29 NA's are 29 water points located beyond the LGA boundary, as shown in the plot below.

```{r}
tmap_mode("view")

tm_shape(bdy_nga) +
  tm_polygons() +
  tm_view(set.zoom.limits = c(5.5, 12))+
  
tm_shape(filter(wp_joined, 
                is.na(wp_reference))) +
  tm_dots(size=0.1,
          col="red")

tmap_mode("plot")
```
:::

[^6]: Daniel et. al (2020) geoBoundaries: A global database of political administrative boundaries. *PlosOne*. <https://doi.org/10.1371/journal.pone.0231866>

### 3.4.3 Remove Water Point Outside LGA Boundary

::: {.callout-warning appearance="simple" icon="false"}
```{r}
#| code-fold: false
wp_joined1 <- wp_joined %>% 
  filter(
    shapeName == clean_adm2 | shapeName != clean_adm2)
```
:::

### 3.4.4 Combine Unique Value

::: {.callout-warning appearance="simple" icon="false"}
There are 9 unique values for "status_clean". However, four (4) of them share the same context :

-   "Non functional due to dry season"

-   "Non-Functional due to dry season"

-   "Abandoned"

-   "Abandoned/Decommissioned"

Hence, the same context values need to combine into one unique value.

```{r}
#| code-fold: false
wp_joined1$status_clean[wp_joined1$status_clean == "Non functional due to dry season"] <- "Non-Functional due to dry season"

wp_joined1$status_clean[wp_joined1$status_clean == "Abandoned"] <- "Abandoned/Decommissioned"
```

#### 3.4.4.1 review combined output

```{r}
unique(wp_joined1$status_clean)
```

#### 3.4.4.2 save and read RDS file :: *wp_joined1*

Save the updated values into wp_joined1 RDS file.

```{r}
#| eval: false
write_rds(wp_joined1,"data/geodata/wp_joined1.rds",compress = "xz")
```

```{r}
#| code-fold: false
wp_joined1 <- read_rds("data/geodata/wp_joined1.rds")
```
:::

## 3.5 Extract Water Point by Attribute

### 3.5.1 Extract Functional Water Point :: *wpt_functional*

::: {.callout-warning appearance="simple" icon="false"}
```{r}
#| eval: false
wpt_functional <- wp_joined1 %>%
  filter(status_clean %in%
           c("Functional", 
             "Functional but not in use",
             "Functional but needs repair"))
```

#### 3.5.1.1 save and read RDS file :: *wpt_functional*

```{r}
#| eval: false
write_rds(wpt_functional,"data/geodata/wpt_functional.rds",compress = "xz")
```

```{r}
#| code-fold: false
wpt_functional <- read_rds("data/geodata/wpt_functional.rds")
```

#### 3.5.1.2 compute data table for clustering analysis

```{r}
wp_nga <- bdy_nga %>%
  mutate(`total_wp` = lengths(
    st_intersects(bdy_nga, wp_joined1))) %>%
  
  mutate(`wp_functional` = lengths(
    st_intersects(bdy_nga, wpt_functional))) %>%
  
  mutate(`pct_functional` = (`wp_functional`/`total_wp`*100))
```
:::

### 3.5.2 Extract Non-Functional Water Point :: *wpt_nonFunctional*

::: {.callout-warning .column-page-right appearance="simple" icon="false"}
```{r}
#| eval: false
wpt_nonFunctional <- wp_joined1 %>%
  filter(status_clean %in%
           c("Abandoned/Decommissioned", 
             "Non-Functional",
             "Non-Functional due to dry season"))
```

#### 3.5.2.1 save and read RDS file :: *wpt_nonFuntional*

```{r}
#| eval: false
write_rds(wpt_nonFunctional,"data/geodata/wpt_nonFunctional.rds",compress = "xz")
```

```{r}
#| code-fold: false
wpt_nonFunctional <- read_rds("data/geodata/wpt_nonFunctional.rds")
```

#### 3.5.2.2 compute additional variables into *wp_nga*

```{r}
wp_nga <- wp_nga %>%
  mutate(`wp_nonFunctional` = lengths(
    st_intersects(bdy_nga, wpt_nonFunctional))) %>%
  mutate(`pct_nonFunctional` = (`wp_nonFunctional`/`total_wp`*100))
```
:::

### 3.5.3 Extract Unknown Water Point

::: {.callout-warning .column-page-right appearance="simple" icon="false"}
```{r}
#| eval: false
wpt_unknown <- wp_joined1 %>%
  filter(status_clean == "Unknown")
```

#### 3.5.3.1 save and read RDS file :: *wpt_unknown*

```{r}
#| eval: false
write_rds(wpt_unknown,"data/geodata/wpt_unknown.rds")
```

```{r}
#| code-fold: false
wpt_unknown <- read_rds("data/geodata/wpt_unknown.rds")
```

#### 3.5.3.2 compute additional variables into *wp_nga*

```{r}
wp_nga <- wp_nga %>%
  mutate(`wp_unknown` = lengths(
    st_intersects(bdy_nga, wpt_unknown))) %>%
  mutate(`pct_unknown` = (`wp_unknown`/`total_wp`*100))
```
:::

### 3.5.4 Extract Water Points by "water_tech_category"

::: {.callout-warning appearance="simple" icon="false"}
```{r}
freq(wp_joined1$water_tech_category)
```

Remarks :

Only "Hand Pump", "Mechanized Pump", and "Tapstand" are to be extracted for further analysis as the rest are either less than 0.5% or "Unknown".

```{r}
#| code-fold: false
wtc_hPump <- wp_joined1 %>%
  filter(water_tech_category %in%
           "Hand Pump")

wtc_mPump <- wp_joined1 %>%
  filter(water_tech_category %in%
           "Mechanized Pump")

wtc_tStand <- wp_joined1 %>%
  filter(water_tech_category %in%
           "Tapstand")

wp_nga <- wp_nga %>%
  mutate(`total_handPump` = lengths(
    st_intersects(bdy_nga, wtc_hPump)
  )) %>%
  mutate(`total_mechPump` = lengths(
    st_intersects(bdy_nga, wtc_mPump)
  )) %>%
    mutate(`total_tapStand` = lengths(
    st_intersects(bdy_nga, wtc_tStand)
  )) %>%
  mutate(`pct_handPump` = (`total_handPump`/`total_wp`*100)) %>%
  mutate(`pct_mechPump` = (`total_mechPump`/`total_wp`*100)) %>%
  mutate(`pct_tapStand` = (`total_tapStand`/`total_wp`*100))
```
:::

### 3.5.5 Extract Water Point by "usage_capacity"

::: {.callout-warning appearance="simple" icon="false"}
```{r}
freq(wp_joined1$usage_capacity)
```

Remarks :

-   Only "300", "1000", and "250" are to be extracted for further analysis as the rest are either less than 0.5% or "Unknown".

-   But, "50" will be included in the new variable "total_ucN1000" as part of the none '1000' "usage_capacity" value.

```{r}
#| code-fold: false
uCap_300 <- wp_joined1 %>%
  filter(usage_capacity %in%
           "300")

uCap_1000 <- wp_joined1 %>%
  filter(usage_capacity %in%
           "1000")

uCap_250 <- wp_joined1 %>%
  filter(usage_capacity %in%
           "250")

uCap_50 <- wp_joined1 %>%
  filter(usage_capacity %in%
           "50")

wp_nga <- wp_nga %>%
  mutate(`total_uc300` = lengths(
    st_intersects(bdy_nga, uCap_300)
  )) %>%
  mutate(`total_uc1000` = lengths(
    st_intersects(bdy_nga, uCap_1000)
  )) %>%
  mutate(`total_uc250` = lengths(
    st_intersects(bdy_nga, uCap_250)
  )) %>%
  mutate(`total_uc50` = lengths(
    st_intersects(bdy_nga, uCap_50)
  )) %>%
  mutate(`total_ucN1000` = ((lengths(
    st_intersects(
      bdy_nga, uCap_300))) + (lengths(
        st_intersects(
          bdy_nga, uCap_250))) + (lengths(
            st_intersects(
              bdy_nga, uCap_50))))
    )%>%
           
  mutate(`pct_ucN1000` = (`total_ucN1000`/`total_wp`*100)) %>%
  mutate(`pct_uc300` = (`total_uc300`/`total_wp`*100)) %>%
  mutate(`pct_uc1000` = (`total_uc1000`/`total_wp`*100)) %>%
  mutate(`pct_uc250` = (`total_uc250`/`total_wp`*100))
```
:::

### 3.5.6 Extract Water Point by "is_urban"

::: {.callout-warning appearance="simple" icon="false"}
```{r}
#| code-fold: false
urban_1 <- wp_joined1 %>%
  filter(is_urban %in%
           "TRUE")

urban_0 <- wp_joined1 %>%
  filter(is_urban %in%
           "FALSE")

wp_nga <- wp_nga %>%
  mutate(`total_urban1` = lengths(st_intersects
                                  (bdy_nga, urban_1)
                                  )) %>%
  mutate(`total_urban0` = lengths(st_intersects
                                  (bdy_nga, urban_0)
                                  )) %>%
  mutate(`pct_urban1` = (`total_urban1`/`total_wp`*100)) %>%
  mutate(`pct_urban0` = (`total_urban0`/`total_wp`*100))
```
:::

### 3.5.7 Save and Read RDS File :: *wp_nga*

::: {.callout-warning appearance="simple" icon="false"}
```{r}
#| eval: false
write_rds(wp_nga,"data/geodata/wp_nga.rds")
```

```{r}
#| code-fold: false
wp_nga <- read_rds("data/geodata/wp_nga.rds")
```
:::

## 3.6 Transform Coordinate System

::: {.callout-warning appearance="simple" icon="false"}
The EPSG for *wp_nga* is 4326, which is WGS 84. To compute the proximity distance matrix for clustering analysis, the coordinate reference system for attribute (wp_nga) and boundary (bdy_nga) data frames needs to transform into EPSG: 26391.

### 3.6.1 Transform Attribute and Boundary

::: {.callout-alert appearance="simple" icon="false"}
[***st_set_crs( )*** - sf -]{style="color:#d46e15"} to update the coordinate reference system.
:::

```{r}
#| code-fold: false
wp_ngaTrans <- st_set_crs(wp_nga, 26391)
bdy_ngaTrans <- st_set_crs(bdy_nga, 26391)
```

### 3.6.2 Review CRS :: *wp_ngaTrans*

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***st_crs( )*** - sf -]{style="color:#d46e15"} to inspect the coordinate reference system.
:::

```{r}
st_crs(wp_ngaTrans)
```

### 3.6.3 Review CRS :: *bdy_ngaTrans*

```{r}
st_crs(bdy_ngaTrans)
```
:::

## 3.7 Exploratory Data Analysis (EDA)

### 3.7.1 Geospatial EDA

::: {.callout-warning .column-page-right appearance="simple" icon="false"}
Reference of the code chunk below source from Lin S.Y., 2022[^7].

```{r}
shapeName_na <- function(x){
  tm_shape(wp_ngaTrans) +
    tm_fill(col=x,
            style="pretty") +
    tm_borders(alpha=0.5) +
    tm_layout(legend.height = 0.2, 
              legend.width = 0.2)
}

eda_wpNA <- map(names(wp_ngaTrans)
                [c(3,5,7,13:15,21:24,28)], 
                shapeName_na)
tmap_arrange(eda_wpNA)
```

Remarks :

The LGA that does not have any water points as shown above to be removed from the data frame.

#### 3.7.1.1 filter state without water point

```{r}
wp_ngaTrim <- wp_ngaTrans %>%
  filter(if_all(
    starts_with("total_wp"),~. > 0))
```

#### 3.7.1.2 visualise distribution of functional and non-functional water points

```{r}
fun <- tm_shape (wp_ngaTrim) +
  tm_fill("pct_functional",
          style = "jenks",
          n=6,
          title = "Functional (%)") +
  tm_layout(main.title = "Distribution of Functional Water Point by LGA",
            main.title.position = "center",
            main.title.size = 0.7,
            main.title.fontface = "bold",
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5)

nfun <- tm_shape (wp_ngaTrim) +
  tm_fill("pct_nonFunctional",
          style = "jenks",
          n=6,
          title = "Non-Functional (%)") +
  tm_layout(main.title = "Distribution of Non Functional Water Point by LGA",
            main.title.position = "center",
            main.title.size = 0.7,
            main.title.fontface = "bold",
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5)

tmap_arrange (fun, nfun, ncol = 2, asp = 1)
```

#### 3.7.1.3 save and read RDS file

::: {.callout-warning appearance="simple" icon="false"}
```{r}
#| eval: false
write_rds(wp_ngaTrim,"data/geodata/wp_ngaTrim.rds")
```

```{r}
#| code-fold: false
wp_ngaTrim <- read_rds("data/geodata/wp_ngaTrim.rds")
```
:::
:::

[^7]: Lin S.Y.(2022). Regionalisation Using Water Point Availability in Nigeria. https://lins-92-isss624.netlify.app/take-home_ex02/take-home_ex02#exploratory-data-analysis

### 3.7.2 Visualise Distribution of Cluster Variable

::: {.callout-warning appearance="simple" icon="false"}
Create a data frame with variables for clustering analysis before visualise the distribution.

#### 3.7.2.1 create cluster variable data frame

```{r}
cluster_vars <- wp_ngaTrim %>%
  st_set_geometry(NULL) %>%
  select("shapeName",
         "total_wp",
         "pct_functional", 
         "pct_nonFunctional",
         "pct_handPump",
         "pct_mechPump",
         "pct_tapStand",
         "pct_uc300",
         "pct_uc1000",
         "pct_ucN1000",
         "pct_uc250",
         "pct_urban0")
```

#### 3.7.2.2 replace row ID with "shapeName"

```{r}
row.names(cluster_vars) <- cluster_vars$shapeName
cluster_vars <- cluster_vars %>%
  select(-shapeName)
```

#### 3.7.2.3 examine distribution of Cluster Variables

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***st_join( )*** - sf -]{style="color:#d46e15"} to join *sf*-class objects based on geometry, namely, *wp_sf* and *bdy_nga*.
:::

Reference of the code chunk below source from Lin S.Y., 2022[^8].

```{r}
plot_num(cluster_vars)
```
:::

[^8]: Lin S.Y.(2022). Regionalisation Using Water Point Availability in Nigeria. https://lins-92-isss624.netlify.app/take-home_ex02/take-home_ex02#exploratory-data-analysis

### 3.7.3 Identify Outliers

::: {.callout-warning appearance="simple" icon="false"}
Boxplot shows the minimum, maximum, median, first quartile, third quartile and outliers, if any.

```{r}
ggarrange(
  (ggplot(data=cluster_vars, aes(x=`pct_functional`)) + 
     geom_boxplot(color="black", fill="#19ff3fFF")), 
  ((ggplot(data=cluster_vars, aes(x=`pct_nonFunctional`)) +
      geom_boxplot(color="black", fill="#ff1919FF"))),
  ((ggplot(data = cluster_vars, aes(x = `pct_handPump`)) +
      geom_boxplot(color="black", fill="#FFA319FF"))),
  ((ggplot(data = cluster_vars, aes(x = `pct_mechPump`)) +
      geom_boxplot(color="black", fill="#ff8419FF"))),
  ((ggplot(data = cluster_vars, aes(x = `pct_tapStand`)) +
      geom_boxplot(color="black", fill="#ff5619FF"))),
  ((ggplot(data = cluster_vars, aes(x = `pct_urban0`)) +
      geom_boxplot(color="black", fill="#19beffFF"))),
  ((ggplot(data = cluster_vars, aes(x = `pct_uc1000`)) +
      geom_boxplot(color="black", fill="#C16622FF"))),
  ((ggplot(data = cluster_vars, aes(x = `pct_ucN1000`)) +
      geom_boxplot(color="black", fill="#543005FF"))),
   ncol = 2,
  nrow = 4)
```

Remarks :
:::

# 4. CORRELATION ANALYSIS

## 4.1 Visualise Correlation Matrix

::: {.callout-warning appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***corrplot.mixed( )*** - corrplot -]{style="color:#d46e15"} to use mixed methods to visualise a correlation matrix.
:::

This plot allows to identify the pattern and the relationship in the matrix.

```{r}
corrplot.mixed((cor(cluster_vars)),
               upper = "number",
               lower = "ellipse",
               tl.col = "black",
               diag = "l",
               tl.pos = "lt")
```

Remarks :

Following are the pairs with strong correlation :

| correlation coefficients |  variable_1  | variable_2  |
|:------------------------:|:------------:|:-----------:|
|           1.00           |  pct_uc1000  | pct_ucN1000 |
|           1.00           | pct_mechPump | pct_uc1000  |
|          -1.00           | pct_mechPump | pct_ucN1000 |
|          -1.00           |  pct_uc1000  | pct_ucN1000 |
|           0.99           | pct_tapStand |  pct_uc250  |
|           0.99           |  pct_uc300   | pct_ucN1000 |
|          -0.99           | pct_mechPump |  pct_uc300  |
|          -0.99           |  pct_uc300   | pct_uc1000  |

Since only "usage_capacity" and "water_tech_category" are showing multicollinearity, hence the study will be split into 2 models with water point status by -

1\) "water_tech_category"

2\) "usage_capacity"
:::

## 4.2 Refine Model :: *cluster_varsTech*

::: {.callout-warning appearance="simple" icon="false"}
### 4.2.1 Remove "usage_capacity"

```{r}
cluster_varsTech <- cluster_vars %>%
  select(-pct_ucN1000, -pct_uc1000, -pct_uc300, -pct_uc250)
```

```{r}
corrplot.mixed((cor(cluster_varsTech)),
               upper = "number",
               lower = "ellipse",
               tl.col = "black",
               diag = "l",
               tl.pos = "lt")
```

Remarks :

"pct_handPump" and "pct_mechPump" are negatively correlated at -0.82.

Since hand pump is the instructed main water point technology in the scope of work, "pct_mechPump" will be removed from the model.

```{r}
cluster_varsTech1 <- cluster_varsTech %>%
  select(-pct_mechPump)
```

#### 4.2.2 Build Regression Model

```{r}
model_test <- lm(total_wp ~ pct_functional + 
         pct_nonFunctional +
         pct_handPump +
         pct_tapStand +
         pct_urban0,
         data = cluster_varsTech1)

summary(model_test)
```

### 4.2.3 Detect Multicollinearity

```{r}
car::vif(model_test)
```

Remarks :

::: callout-alert
When encountering the following error :

*" Error in vif.default(model_test) : there are aliased coefficients in the mode "*

It means two or more predictor variables in the model are perfectly correlated.
:::

::: callout-note
Variables with VIF threshold value between 5 to 10 may need to be cautious but VIF greater than 10 can be problematic to the model performance due to serious collinearity problem.[^9]

"A VIF value of 10 means that the tolerance of the relevant independent variable is 0.10 and that 90% (𝐑𝟐) of the variable is explained by other variables. This is undesirable, as it indicates that **the relevant independent variable is unnecessarily included in the model**."[^10]

When a study involve a large sample size, the VIF threshold value can be set up to 10.
:::

Based on the VIF report, there is no multicollinearity in the model.
:::

[^9]: Chouiry G. (2022). What is an Acceptable Value for VIF? (With References). https://quantifyinghealth.com/vif-threshold/

[^10]: ResearchGate. Multicollinearity issues: is a value less than 10 acceptable for VIF? https://www.researchgate.net/post/Multicollinearity_issues_is_a\_value_less_than_10_acceptable_for_VIF

# 5. DATA STANDARDISATION

## 5.1 Tidy Data Frame

```{r}
cluster_varsTech2 <- cluster_varsTech1 %>%
  select(-total_wp)
```

## 5.2 Standardise Data

As shown in 3.7.3.3, not all variables are not distributed normally. Hence, standardisation will be required before the clustering analysis.

::: {.callout-warning appearance="simple" icon="false"}
### 5.2.1 Standardise :: Min-Max Method

```{r}
wp_stdMM <- normalize(cluster_varsTech2)
describe(wp_stdMM)
```

### 5.2.2 Standardise :: Z-score Method

```{r}
wp_stdZ <- scale(cluster_varsTech2)
describe(wp_stdZ)
```

Remarks :

Comparing the reports above, the Min-Max method is the only method that can standardise the value to between 0 and 1.

### 5.2.3 Compare Distribution For Standardisation Method

Visualise to determine which standardisation method provide the better output.

```{r}
ggarrange(
  (ggplot(data = cluster_varsTech2, aes(x = `pct_functional`)) +
    geom_density(color = "black", fill = "#19ff3fFF") + 
    ggtitle("Before Standardisation")),
  (ggplot(data = (as.data.frame(wp_stdMM)), aes(x = `pct_functional`)) +
      geom_density(color = "black", fill = "#19ff3fFF") +
      ggtitle("Min-Max Stdsn.")),
  (ggplot(data = (as.data.frame(wp_stdZ)), aes(x = `pct_functional`)) +
     geom_density(color = "black", fill="#19ff3fFF") +
     ggtitle("Z-score Stdsn.")),
   ncol = 3)
```

```{r}
ggarrange(
  (ggplot(data = cluster_varsTech2, aes(x = `pct_nonFunctional`)) +
    geom_density(color = "black", fill = "#ff1919FF") + 
    ggtitle("Before Standardisation")),
  (ggplot(data = (as.data.frame(wp_stdMM)), aes(x = `pct_nonFunctional`)) +
      geom_density(color = "black", fill = "#ff1919FF") +
      ggtitle("Min-Max Stdsn.")),
  (ggplot(data = (as.data.frame(wp_stdZ)), aes(x = `pct_nonFunctional`)) +
     geom_density(color = "black", fill="#ff1919FF") +
     ggtitle("Z-score Stdsn.")),
   ncol = 3)
```

```{r}
ggarrange(
  (ggplot(data = cluster_varsTech2, aes(x = `pct_handPump`)) +
    geom_density(color = "black", fill = "#FFA319FF") + 
    ggtitle("Before Standardisation")),
  (ggplot(data = (as.data.frame(wp_stdMM)), aes(x = `pct_handPump`)) +
      geom_density(color = "black", fill = "#FFA319FF") +
      ggtitle("Min-Max Stdsn.")),
  (ggplot(data = (as.data.frame(wp_stdZ)), aes(x = `pct_handPump`)) +
     geom_density(color = "black", fill="#FFA319FF") +
     ggtitle("Z-score Stdsn.")),
   ncol = 3)
```

```{r}
ggarrange(
  (ggplot(data = cluster_varsTech2, aes(x = `pct_tapStand`)) +
    geom_density(color = "black", fill = "#ff5619FF") + 
    ggtitle("Before Standardisation")),
  (ggplot(data = (as.data.frame(wp_stdMM)), aes(x = `pct_tapStand`)) +
      geom_density(color = "black", fill = "#ff5619FF") +
      ggtitle("Min-Max Stdsn.")),
  (ggplot(data = (as.data.frame(wp_stdZ)), aes(x = `pct_tapStand`)) +
     geom_density(color = "black", fill="#ff5619FF") +
     ggtitle("Z-score Stdsn.")),
   ncol = 3)
```

```{r}
ggarrange(
  (ggplot(data = cluster_varsTech2, aes(x = `pct_urban0`)) +
    geom_density(color = "black", fill = "#19beffFF") + 
    ggtitle("Before Standardisation")),
  (ggplot(data = (as.data.frame(wp_stdMM)), aes(x = `pct_urban0`)) +
      geom_density(color = "black", fill = "#19beffFF") +
      ggtitle("Min-Max Stdsn.")),
  (ggplot(data = (as.data.frame(wp_stdZ)), aes(x = `pct_urban0`)) +
     geom_density(color = "black", fill="#19beffFF") +
     ggtitle("Z-score Stdsn.")),
   ncol = 3)
```
:::

# 6. CLUSTERING ANALYSIS

## 6.1 Hierarchical Clustering

There are [four (4) main steps](https://www.learndatasci.com/glossary/hierarchical-clustering/) :

-   compute proximity matrix and determine clustering algorithm.
-   compute Hierarchical Clustering.
-   identify optimal number of cluster and merge similar clusters.
-   update the distance matrix.

### 6.1.1 Compute Proximity Matrix and Clustering Algorithm

::: {.callout-warning appearance="simple" icon="false"}
First determine the clustering algorithm before compute Hierarchical Clustering analysis.

#### 6.1.1.1 determine Hierarchical Clustering algorithm

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***agnes( )*** - cluster -]{style="color:#d46e15"} to get agglomerative coefficient of 4 clustering structure, namely "average", "single", "complete" and "ward".
:::

```{r}
m <- c("average","single","complete","ward")

names(m) <- c("average","single","complete","ward")

ac <- function(x){agnes(wp_stdMM, method = x)$ac}

map_dbl(m, ac)
```

Remarks :

-   Value 1 indicates the strongest clustering structure.

-   Ward's method provides the strongest clustering structure. Therefore, Ward's method is to be used in subsequent analysis.

#### 6.1.1.2 compute proximity matrix

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***dist( )*** - stats -]{style="color:#d46e15"} to compute the proximity distance matrix. Among **euclidean, maximum, manhattan, canberra, binary and minkowski**, *euclidean* is used to compute *proxmat_euc.*
:::

```{r}
prox_mat_euc <- dist(wp_stdMM, 
                     method = 'euclidean')
```
:::

### 6.1.2 Compute Hierarchical Clustering

::: {.callout-warning appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***hclust( )*** - stats -]{style="color:#d46e15"} to compute cluster with agglomeration method.

[***ggdendrogram( )*** - ggdendro -]{style="color:#d46e15"} to plot dendrogram with tools available in [ggplot2]{style="color:#d46e15"}.
:::

```{r}
hclust_ward <- hclust(prox_mat_euc, 
                      method = 'ward.D')
ggdendrogram(hclust_ward,
             rotate = TRUE,
             cex = 0.1,
             theme_dendro = FALSE)
```

Remarks :

This is in spite of adjusting the *cex=* parameter that scales the resolution of the dendogram to 10%. [^11]
:::

[^11]: Chua Y.T. (2022). Take-home Exercise 2 - Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods. https://isss624-amelia.netlify.app/exercises/take-home_ex2/take-home_ex2#computing-hierarchical-clustering

### 6.1.3 Identify Number of Optimal Cluster

::: {.callout-warning appearance="simple" icon="false"}
To determine the optimal clusters to retain, following commons methods are tested :

-   Gap statistic

-   Elbow

-   Average Silhouette

#### 6.1.3.1 compute Gap Statistic method

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***clusGap( )*** - cluster -]{style="color:#d46e15"} to compute the gap statistic.
:::

```{r}
set.seed(12345)

gap_stat <- clusGap(wp_stdMM, 
                    FUN = hcut, 
                    nstart = 25, 
                    K.max = 7, 
                    B = 50)

print(gap_stat, method = "firstmax")
```

Remarks :

The number of clusters recommended by "firstmax" approach of Gap Statistic method is 5.

#### 6.1.3.2 visualise *gap_stat*

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***fviz_nbclust( )*** - factoextra -]{style="color:#d46e15"} to compute and visualise the Optimal Number of clusters.
:::

```{r}
set.seed(12345)

fviz_nbclust(wp_stdMM,
             FUNcluster = hcut,
             nstart = 25,  
             method = "gap_stat", 
             nboot = 50,
             linecolor = "white")+
  theme_dark() +
  labs(subtitle = "Gap statistic method")
```

#### 6.1.3.3 compute and visualise Total Within Sum of Squares (Elbow) method

```{r}
fviz_nbclust(wp_stdMM, 
             kmeans, 
             method = "wss",
             linecolor = "white")+
  theme_dark() +
  labs(subtitle = "Elbow method")
```

#### 6.1.3.4 compute and visualise Silhouette method

```{r}
fviz_nbclust(wp_stdMM, 
             kmeans, 
             method = "silhouette",
             linecolor = "white") +
  theme_dark() +
  labs(subtitle = "Silhouette method")
```

Remarks :

| Method              | Gap stat | Elbow | Silhouette |
|---------------------|----------|-------|------------|
| Optimal Value for K | 5        | 3     | 3          |

Given the Elbow method, Silhouette method and Gap Statistic method, the 5-cluster by Silhouette method will be used for the rest of the study.
:::

### 6.1.4 Merge Similar Clusters

::: {.callout-warning appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***rect.hclust( )*** - stats -]{style="color:#d46e15"} to draw the dendrogram with a border around the selected clusters.
:::

```{r}
plot(hclust_ward, cex = 0.5)
rect.hclust(hclust_ward, 
            k = 5, 
            border = 2:5)
```
:::

### 6.1.5 Visually-Driven Hierarchical Clustering Analysis

::: {.callout-warning appearance="simple" icon="false"}
The data is loaded into a data frame, but it has to be a data matrix to plot the heatmap. Hence, the data frame will need to first transform into a matrix.

#### 6.1.5.1 transform data frame into matrix

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***data.matrix( )*** - base -]{style="color:#d46e15"} to transform *cluster_varsTrim* data frame into a data matrix, and named it as *nga_clustMat*.
:::

```{r}
wp_stdMM_mat <- data.matrix(wp_stdMM)
```

#### 6.1.5.2 plot interactive cluster heatmap

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***heatmaply( )*** - heatmaply -]{style="color:#d46e15"} to build an interactive cluster heatmap.
:::

```{r}
heatmaply(normalize(wp_stdMM_mat),
          Colv = NA,
          dist_method = "euclidean",
          hclust_method = "ward.D",
          seriate = "OLO",
          colors = Blues,
          k_row = 5,
          margins = c(NA,200,60,NA),
          fontsize_row = 1,
          fontsize_col = 5,
          main="Geographic Segmentation of Nigeria by Water Points",
          xlab = "Water Points",
          ylab = "Nigeria LGA"
          )
```

Remarks :

Cluster 4 and 5 have higher percentage of functional water points.

Cluster 1, 2 and 3 have higher percentage of non-functional water points.

Cluster 1, 2, 4 and 5 have higher percentage of hand pump deployed for the water points.

Cluster 2, 3 and 5 have higher percentage of rural communities.

#### 6.1.5.3 create 5-cluster model

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***cutree( )*** - base -]{style="color:#d46e15"} to derive a 5-cluster model, and named the output as *groups*.
:::

```{r}
groups <- as.factor(cutree(hclust_ward, k = 5))
```

#### 6.1.5.4 append *groups* to *wp_ngaTrim*

```{r}
nga_clust.sf <- cbind(wp_ngaTrim, as.matrix(groups)) %>%
  rename(`cluster`=`as.matrix.groups.`)
```

#### 6.1.5.5 plot choropleth map :: *nga_clust.sf*

```{r}
clusGeo.map <- tm_shape(nga_clust.sf) +
  tm_fill(col = "cluster",
          title = "Cluster") +
  tm_borders(alpha = 0.3) +
  tm_layout(main.title = "Non-Spatial with Hierarchical Clustering",
            main.title.size = 1.2,
            main.title.position = "center",
            legend.height = 0.4,
            legend.width = 0.2, 
            legend.title.size = 2,
            legend.text.size = 2,
            frame = TRUE)

clusGeo.map
```

Remarks :

The choropleth map above shows the fragmented clusters by the used of non-spatial clustering algorithm (hierarchical cluster analysis method).
:::

## 6.2 Spatially Constrained Clustering :: SKATER Approach

SKATER function only support sp objects in SpatialPolygonDataFrame. Hence, the *wp_ngaTrans* has to first transform into SpatialPolygonDataFrame before proceed further.

### 6.2.1 Convert SF to SP Data Frame

::: {.callout-warning appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***as_Spatial( )*** - sf -]{style="color:#d46e15"} to convert *wp_ngaTrans* into *nga_sp* in a SP data frame.
:::

```{r}
nga.sp <- as_Spatial(wp_ngaTrim)
```
:::

### 6.2.2 Compute Neighbour List

::: {.callout-warning appearance="simple" icon="false"}
First compute the neighbour list before plot it.

### 6.2.2.1 compute neighbour list from polygon list

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***poly2nb( )*** - spdep -]{style="color:#d46e15"} to compute the neighbours list from polygon list.
:::

```{r}
nga.nb <- poly2nb(nga.sp, queen = TRUE)

summary(nga.nb)
```

Remarks :

There is no LGA without link.

#### 6.2.2.2 plot Neighbour List by Centroid Node

[Usage of the code chunk below :]{style="color:#a39f9d"} plot the boundary first before the neighbour list object to avoid any region from being clipped away.

```{r}
plot(nga.sp, 
     border = grey(.5))

plot(nga.nb, 
     coordinates(nga.sp), 
     col = "blue", 
     add = TRUE)
```
:::

### 6.2.3 Compute Minimum Spanning Tree (MST)

::: {.callout-warning appearance="simple" icon="false"}
To find a minimum path connecting all nodes in a graph, a minimum spanning tree with minimum weight than all other spanning trees to be used in subsequent steps.

#### 6.2.3.1 calculate edge costs

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***nbcosts( )*** - spdep -]{style="color:#d46e15"} to compute the cost of each edge which is the distance between nodes.
:::

```{r}
edge_cost <- nbcosts(nga.nb, wp_stdMM)
```

#### 6.2.3.2 specify spatial weight

::: {.callout-alert appearance="simple" icon="false"}
[***nb2listw( )*** - spdep -]{style="color:#d46e15"} to specify *edge_cost* as the spatial weights. Set the "style" to "B" to ensure the cost values are not row-standardised.
:::

```{r}
nga.w <- nb2listw(nga.nb,
                  edge_cost,
                  style = "B")
summary(nga.w)
```

#### 6.2.3.3 compute MST

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***nbcosts( )*** - spdep -]{style="color:#d46e15"} to compute the minimum spanning tree.
:::

```{r}
nga_minSpanT <- mstree(nga.w)
```

#### 6.2.3.4 review class and dimension of the computed MST

```{r}
class(nga_minSpanT)
```

```{r}
dim(nga_minSpanT)
```

```{r}
head(nga_minSpanT)
```

#### 6.2.3.5 plot MST Neighbour List

```{r}
plot(nga.sp, border = gray(.5))

plot.mst(nga_minSpanT,
         coordinates(nga.sp), 
         col = "blue", 
         cex.lab = 0.7, 
         cex.circles = 0.005, 
         add = TRUE)
```
:::

### 6.2.4 Compute Spatially Constrained Cluster

::: {.callout-warning appearance="simple" icon="false"}
::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***skater( )*** - spdep -]{style="color:#d46e15"} to compute the spatially constrained cluster.

note: ncuts = number of clusters - 1
:::

```{r}
clust5 <- spdep::skater(edges = nga_minSpanT[,1:2],
                        data = cluster_varsTech2,
                        method = "euclidean",
                        ncuts = 4)
str(clust5)
```

#### 6.2.4.1 tabulate cluster assignment

```{r}
ccs5 <- clust5$groups
table(ccs5)
```

#### 6.2.4.2 plot the pruned tree

```{r}
plot(nga.sp, border = gray(.5))
plot(clust5, 
     coordinates(nga.sp), 
     cex.lab = .7,
     groups.colors = c("red","green","blue", "brown"),
     cex.circles = 0.005, 
     add = TRUE)
```
:::

### 6.2.5 Visualise SKATER Clusters in Choropleth Map

::: {.callout-warning appearance="simple" icon="false"}
```{r}
groups_mat <- as.matrix(clust5$groups)

nga_spClust.sf <- cbind(nga_clust.sf, 
                        as.factor(groups_mat)) %>%
  rename(`sp_cluster`=`as.factor.groups_mat.`)
```

To compare the output of hierarchical clustering and spatially constrained hierarchical clustering :

```{r}
clusGeo_SKAT.map <- tm_shape(nga_spClust.sf) +
  tm_fill(col = "sp_cluster",
          title = "Cluster") +
  tm_borders(alpha = 0.3) +
  tm_layout(main.title = "Spatially Constrained with SKATER Method",
            main.title.size = 1.2,
            main.title.position = "center",
            legend.height = 0.4,
            legend.width = 0.2, 
            legend.title.size = 2,
            legend.text.size = 2,
            frame = TRUE)

clusGeo_SKAT.map
```
:::

## 6.3 ClustGeo Method

This section consists of two (2) parts i.e. spatially and non-spatially Constrained Cluster analysis.

### 6.3.1 Non-Spatially Constrained Hierarchical Cluster Analysis

::: {.callout-warning appearance="simple" icon="false"}
Dissimilarity matrix must be an object of class dist.

#### 6.3.1.1 create Class `dist` Object

```{r}
proxmat_ngc <- dist(wp_stdMM, method = 'euclidean')
```

#### 6.3.1.2 compute Non-Spatially Constrained Hierarchical Clustering

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***hclustgeo( )*** - ClustGeo -]{style="color:#d46e15"} to perform a typical Ward-like hierarchical clustering.
:::

```{r}
nonGeo_clust <- hclustgeo(proxmat_ngc)
plot(nonGeo_clust, 
     cex = 0.5)
rect.hclust(nonGeo_clust, 
            k = 5, 
            border = 2:5)
```

#### 6.3.1.3 derive 5-cluster model

```{r}
groups_ngc <- as.factor(cutree(nonGeo_clust, 
                               k = 5))
```

#### 6.3.1.4 combine *groups_ngc* with *wp_ngaTrim*

```{r}
nga_ngeo_clust.sf <- cbind(wp_ngaTrim, as.matrix(groups_ngc)) %>%
  rename(`cluster` = `as.matrix.groups_ngc.`)
```

#### 6.3.1.5 visualise Non-Spatially Constrained Hierarchical Cluster

```{r}
clusGeo_nSp.map <- tm_shape(nga_ngeo_clust.sf) +
  tm_fill(col = "cluster",
          title = "Cluster") +
  tm_borders(alpha = 0.3) +
  tm_layout(main.title = "Non-Spatially Constrained with ClustGeo Method",
            main.title.size = 1.2,
            main.title.position = "center",
            legend.height = 0.4,
            legend.width = 0.2, 
            legend.title.size = 2,
            legend.text.size = 2,
            frame = TRUE)

clusGeo_nSp.map
```
:::

### 6.3.2 Spatially Constrained Hierarchical Cluster Analysis

::: {.callout-warning appearance="simple" icon="false"}
#### 6.3.2.1 determine Spatial Distance Matrix

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***st_distance( )*** - sf -]{style="color:#d46e15"} to derive the spatial distance matrix before perform spatially constrained hierarchical clustering.

[***as.dist( )*** - stats -]{style="color:#d46e15"} to convert the data frame into matrix.
:::

```{r}
dist <- st_distance(wp_ngaTrim, wp_ngaTrim)
dist_mat <- as.dist(dist)
```

#### 6.3.2.2 determine Alpha value

::: {.callout-alert appearance="simple" icon="false"}
[***choicealpha( )*** - psych -]{style="color:#d46e15"} to determine a suitable value for the mixing parameter alpha.
:::

```{r}
cr <- choicealpha(
  proxmat_ngc, 
  dist_mat, 
  range.alpha = seq(0, 1, 0.1), 
  K = 5, 
  graph = TRUE)
```

Remarks :

With reference to the plot above, alpha = 0.5 to be used to perform spatially constrained hierarchical clustering.

#### 6.3.2.3 compute Spatially Constrained Hierarchical Clustering

```{r}
clustG <- hclustgeo(proxmat_ngc, 
                    dist_mat, 
                    alpha = 0.5)
```

#### 6.3.2.4 derive "cluster" Object

```{r}
groups_cg <- as.factor(cutree(clustG, k = 5))
```

#### 6.3.2.5 combine *groups_cg* with *wp_ngaTrim*

```{r}
wp_nga_clustG <- cbind(wp_ngaTrim, as.matrix(groups_cg)) %>%
  rename(`cluster` = `as.matrix.groups_cg.`)
```

#### 6.3.2.6 Visualise Spatially Constrained Hierarchical Clustering

```{r}
clusGeo_sp.map <- tm_shape(wp_nga_clustG) +
  tm_fill(col = "cluster",
          title = "Cluster") +
  tm_borders(alpha = 0.3) +
  tm_layout(main.title = "Spatially Constrained with ClustGeo Method",
            main.title.size = 1.2,
            main.title.position = "center",
            legend.height = 0.4,
            legend.width = 0.2, 
            legend.title.size = 2,
            legend.text.size = 2,
            frame = TRUE)

clusGeo_sp.map
```
:::

# 7. VISUAL INTERPRETATION

## 7.1 Visualise Individual Clustering Variable

### 7.1.1 Plot Boxplot

::: {.callout-warning appearance="simple" icon="false"}
```{r}
ggplot(data = nga_ngeo_clust.sf,
       aes(x = cluster, y = pct_nonFunctional)) +
  geom_boxplot()
```

Remarks :

The boxplot reveals Cluster 3 displays the highest mean of non-functional water points. This is followed by Cluster 2.
:::

### 7.1.2 Visualise Multivariate

::: {.callout-warning appearance="simple" icon="false"}
#### 7.1.2.1 prepare data frame

```{r}
nga_ngeo_clust.sf1 <- nga_ngeo_clust.sf %>%
  select("shapeName", 
         "pct_functional", 
         "pct_nonFunctional",
         "pct_handPump", 
         "pct_tapStand",
         "pct_urban0",
         "cluster")
         
head(nga_ngeo_clust.sf1,3)
```

#### 7.1.2.2 plot parallel coordinate plot

::: {.callout-alert appearance="simple" icon="false"}
[Usage of the code chunk below :]{style="color:#a39f9d"}

[***ggparcoord( )*** - GGally -]{style="color:#d46e15"} to plot static parallel coordinate plots to reveal distribution of variables by cluster.

-   `scale` is a character string with the following options -

    -   std : **univariately**, **subtract mean** & **divide by standard deviation**.

    -   robust : **univariately**, **subtract median** & **divide by median absolute deviation**.

    -   uniminmax : **univariately**, scale the minimum to 0, the maximum to 1.

    -   globalminmax : **no scaling**; the range of the graphs is defined by the global minimum and the global maximum.

    -   center : **use uniminmax** to standardize vertical height, then center each variable at a value specified by the scaleSummary param.

    -   centerObs : **use uniminmax to** standardize vertical height, then center each variable at the value of the observation specified by the centerObsID param
:::

```{r}
ggparcoord(data = nga_ngeo_clust.sf1[
  nga_ngeo_clust.sf1$cluster %in% c(2:6),],
           columns = c(2:6),
           scale = "uniminmax",
           alphaLines = 0.2,
           boxplot = TRUE,
           groupColumn = 3) +
  labs(title = "Visual Clustering for ClustGeo Method Spatially Constrained Clustering",
       subtitle = "Multiple Parallel Coordinates Plot") +
  scale_color_viridis(discrete = FALSE) +
  facet_grid(~ cluster,) +
  theme(axis.text.x = element_text(angle = 90),
        text = element_text(size = 12))
```

Remarks :

Based on the parallel coordinate plot above, insights for the stakeholder or decision makers from :

-   the Federal Ministry of Agriculture & Rural Development (FMARD) -

    -   Cluster 2 LGA has the highest percentage of non-functional water points, followed by Cluster 1 LGA.

    -   Cluster 2 also has the highest percentage of rural communities.

!!!!! 1 cluster is missing. Evaluation may be misled.
:::

## 7.2 Compare Clustering Method Visually

::: {.callout-warning .column-page-right appearance="simple" icon="false"}
```{r}
tmap_arrange(clusGeo.map, clusGeo_SKAT.map, clusGeo_nSp.map, clusGeo_sp.map,
             ncol = 2)
```
:::

# 8. CONCLUSION

## 8.1 Conclude with Summary Statistics

::: {.callout-warning appearance="simple" icon="false"}
```{r}
nga_ngeo_clust.sf1 %>% 
  st_set_geometry(NULL) %>%
  group_by(cluster) %>%
  summarise(mean_pct_functional = mean(pct_functional),
            mean_pct_nonFunctional = mean(pct_nonFunctional),
            mean_pct_handPump = mean(pct_handPump), 
            mean_pct_tapStand = mean(pct_tapStand), 
            mean_pct_urban0 = mean(pct_urban0))
         
```

Remarks :

Non-Functional Water Point

-   More than 90% of the water points in Cluster 3 are within non-urban communities, and approximately 62% of these water points are non-functional.

-   Although Cluster 2 and Cluster 5 have similar percentage of approximately 88% water points falls within non-urban communities, the non-functional water points in Cluster 2 is more than twice the amount in Cluster 5 LGA.

    -   Resources may required to attain more information regarding the stakeholder who task to maintain the water points that identified as non-functional but having status indicated otherwise.

    -   !!!! Analysis need to include parameter such as "status" to support the statement above.

-   Cluster 1, however, may require more resources to update the water point data. Unlike Cluster 2, 3, and 5 where more than 85% of water points are updated with data, only two-third of Cluster 1's water points status and various attributes are known.
:::
